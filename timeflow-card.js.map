{"version":3,"file":"timeflow-card.js","sources":["node_modules/tslib/tslib.es6.js","node_modules/@lit/reactive-element/css-tag.js","node_modules/@lit/reactive-element/reactive-element.js","node_modules/lit-html/lit-html.js","node_modules/lit-element/lit-element.js","node_modules/@lit/reactive-element/decorators/property.js","node_modules/@lit/reactive-element/decorators/state.js","src/services/StandardTimer.ts","src/services/AlexaTimer.ts","src/services/GoogleTimer.ts","src/services/Timer.ts","src/utils/DateParser.ts","src/utils/ConfigValidator.ts","src/services/TemplateService.ts","src/services/CountdownService.ts","src/utils/StyleManager.ts","node_modules/lit-html/directive.js","src/utils/handle-action.ts","src/utils/action-handler.ts","src/utils/ErrorDisplay.ts","src/components/TimeFlowCard.ts","src/components/ProgressCircle.ts","src/components/TimeFlowCardEditor.ts","src/index.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nvar ownKeys = function(o) {\r\n    ownKeys = Object.getOwnPropertyNames || function (o) {\r\n        var ar = [];\r\n        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\r\n        return ar;\r\n    };\r\n    return ownKeys(o);\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    var r, s = 0;\r\n    function next() {\r\n        while (r = env.stack.pop()) {\r\n            try {\r\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n                if (r.dispose) {\r\n                    var result = r.dispose.call(r.value);\r\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                else s |= 1;\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\r\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\r\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\r\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\r\n        });\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __esDecorate: __esDecorate,\r\n    __runInitializers: __runInitializers,\r\n    __propKey: __propKey,\r\n    __setFunctionName: __setFunctionName,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,\r\n};\r\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst t=globalThis,e=t.ShadowRoot&&(void 0===t.ShadyCSS||t.ShadyCSS.nativeShadow)&&\"adoptedStyleSheets\"in Document.prototype&&\"replace\"in CSSStyleSheet.prototype,s=Symbol(),o=new WeakMap;class n{constructor(t,e,o){if(this._$cssResult$=!0,o!==s)throw Error(\"CSSResult is not constructable. Use `unsafeCSS` or `css` instead.\");this.cssText=t,this.t=e}get styleSheet(){let t=this.o;const s=this.t;if(e&&void 0===t){const e=void 0!==s&&1===s.length;e&&(t=o.get(s)),void 0===t&&((this.o=t=new CSSStyleSheet).replaceSync(this.cssText),e&&o.set(s,t))}return t}toString(){return this.cssText}}const r=t=>new n(\"string\"==typeof t?t:t+\"\",void 0,s),i=(t,...e)=>{const o=1===t.length?t[0]:e.reduce(((e,s,o)=>e+(t=>{if(!0===t._$cssResult$)return t.cssText;if(\"number\"==typeof t)return t;throw Error(\"Value passed to 'css' function must be a 'css' function result: \"+t+\". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.\")})(s)+t[o+1]),t[0]);return new n(o,t,s)},S=(s,o)=>{if(e)s.adoptedStyleSheets=o.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet));else for(const e of o){const o=document.createElement(\"style\"),n=t.litNonce;void 0!==n&&o.setAttribute(\"nonce\",n),o.textContent=e.cssText,s.appendChild(o)}},c=e?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e=\"\";for(const s of t.cssRules)e+=s.cssText;return r(e)})(t):t;export{n as CSSResult,S as adoptStyles,i as css,c as getCompatibleStyle,e as supportsAdoptingStyleSheets,r as unsafeCSS};\n//# sourceMappingURL=css-tag.js.map\n","import{getCompatibleStyle as t,adoptStyles as s}from\"./css-tag.js\";export{CSSResult,css,supportsAdoptingStyleSheets,unsafeCSS}from\"./css-tag.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */const{is:i,defineProperty:e,getOwnPropertyDescriptor:h,getOwnPropertyNames:r,getOwnPropertySymbols:o,getPrototypeOf:n}=Object,a=globalThis,c=a.trustedTypes,l=c?c.emptyScript:\"\",p=a.reactiveElementPolyfillSupport,d=(t,s)=>t,u={toAttribute(t,s){switch(s){case Boolean:t=t?l:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t)}return t},fromAttribute(t,s){let i=t;switch(s){case Boolean:i=null!==t;break;case Number:i=null===t?null:Number(t);break;case Object:case Array:try{i=JSON.parse(t)}catch(t){i=null}}return i}},f=(t,s)=>!i(t,s),b={attribute:!0,type:String,converter:u,reflect:!1,useDefault:!1,hasChanged:f};Symbol.metadata??=Symbol(\"metadata\"),a.litPropertyMetadata??=new WeakMap;class y extends HTMLElement{static addInitializer(t){this._$Ei(),(this.l??=[]).push(t)}static get observedAttributes(){return this.finalize(),this._$Eh&&[...this._$Eh.keys()]}static createProperty(t,s=b){if(s.state&&(s.attribute=!1),this._$Ei(),this.prototype.hasOwnProperty(t)&&((s=Object.create(s)).wrapped=!0),this.elementProperties.set(t,s),!s.noAccessor){const i=Symbol(),h=this.getPropertyDescriptor(t,i,s);void 0!==h&&e(this.prototype,t,h)}}static getPropertyDescriptor(t,s,i){const{get:e,set:r}=h(this.prototype,t)??{get(){return this[s]},set(t){this[s]=t}};return{get:e,set(s){const h=e?.call(this);r?.call(this,s),this.requestUpdate(t,h,i)},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)??b}static _$Ei(){if(this.hasOwnProperty(d(\"elementProperties\")))return;const t=n(this);t.finalize(),void 0!==t.l&&(this.l=[...t.l]),this.elementProperties=new Map(t.elementProperties)}static finalize(){if(this.hasOwnProperty(d(\"finalized\")))return;if(this.finalized=!0,this._$Ei(),this.hasOwnProperty(d(\"properties\"))){const t=this.properties,s=[...r(t),...o(t)];for(const i of s)this.createProperty(i,t[i])}const t=this[Symbol.metadata];if(null!==t){const s=litPropertyMetadata.get(t);if(void 0!==s)for(const[t,i]of s)this.elementProperties.set(t,i)}this._$Eh=new Map;for(const[t,s]of this.elementProperties){const i=this._$Eu(t,s);void 0!==i&&this._$Eh.set(i,t)}this.elementStyles=this.finalizeStyles(this.styles)}static finalizeStyles(s){const i=[];if(Array.isArray(s)){const e=new Set(s.flat(1/0).reverse());for(const s of e)i.unshift(t(s))}else void 0!==s&&i.push(t(s));return i}static _$Eu(t,s){const i=s.attribute;return!1===i?void 0:\"string\"==typeof i?i:\"string\"==typeof t?t.toLowerCase():void 0}constructor(){super(),this._$Ep=void 0,this.isUpdatePending=!1,this.hasUpdated=!1,this._$Em=null,this._$Ev()}_$Ev(){this._$ES=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$E_(),this.requestUpdate(),this.constructor.l?.forEach((t=>t(this)))}addController(t){(this._$EO??=new Set).add(t),void 0!==this.renderRoot&&this.isConnected&&t.hostConnected?.()}removeController(t){this._$EO?.delete(t)}_$E_(){const t=new Map,s=this.constructor.elementProperties;for(const i of s.keys())this.hasOwnProperty(i)&&(t.set(i,this[i]),delete this[i]);t.size>0&&(this._$Ep=t)}createRenderRoot(){const t=this.shadowRoot??this.attachShadow(this.constructor.shadowRootOptions);return s(t,this.constructor.elementStyles),t}connectedCallback(){this.renderRoot??=this.createRenderRoot(),this.enableUpdating(!0),this._$EO?.forEach((t=>t.hostConnected?.()))}enableUpdating(t){}disconnectedCallback(){this._$EO?.forEach((t=>t.hostDisconnected?.()))}attributeChangedCallback(t,s,i){this._$AK(t,i)}_$ET(t,s){const i=this.constructor.elementProperties.get(t),e=this.constructor._$Eu(t,i);if(void 0!==e&&!0===i.reflect){const h=(void 0!==i.converter?.toAttribute?i.converter:u).toAttribute(s,i.type);this._$Em=t,null==h?this.removeAttribute(e):this.setAttribute(e,h),this._$Em=null}}_$AK(t,s){const i=this.constructor,e=i._$Eh.get(t);if(void 0!==e&&this._$Em!==e){const t=i.getPropertyOptions(e),h=\"function\"==typeof t.converter?{fromAttribute:t.converter}:void 0!==t.converter?.fromAttribute?t.converter:u;this._$Em=e;const r=h.fromAttribute(s,t.type);this[e]=r??this._$Ej?.get(e)??r,this._$Em=null}}requestUpdate(t,s,i){if(void 0!==t){const e=this.constructor,h=this[t];if(i??=e.getPropertyOptions(t),!((i.hasChanged??f)(h,s)||i.useDefault&&i.reflect&&h===this._$Ej?.get(t)&&!this.hasAttribute(e._$Eu(t,i))))return;this.C(t,s,i)}!1===this.isUpdatePending&&(this._$ES=this._$EP())}C(t,s,{useDefault:i,reflect:e,wrapped:h},r){i&&!(this._$Ej??=new Map).has(t)&&(this._$Ej.set(t,r??s??this[t]),!0!==h||void 0!==r)||(this._$AL.has(t)||(this.hasUpdated||i||(s=void 0),this._$AL.set(t,s)),!0===e&&this._$Em!==t&&(this._$Eq??=new Set).add(t))}async _$EP(){this.isUpdatePending=!0;try{await this._$ES}catch(t){Promise.reject(t)}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){if(!this.isUpdatePending)return;if(!this.hasUpdated){if(this.renderRoot??=this.createRenderRoot(),this._$Ep){for(const[t,s]of this._$Ep)this[t]=s;this._$Ep=void 0}const t=this.constructor.elementProperties;if(t.size>0)for(const[s,i]of t){const{wrapped:t}=i,e=this[s];!0!==t||this._$AL.has(s)||void 0===e||this.C(s,void 0,i,e)}}let t=!1;const s=this._$AL;try{t=this.shouldUpdate(s),t?(this.willUpdate(s),this._$EO?.forEach((t=>t.hostUpdate?.())),this.update(s)):this._$EM()}catch(s){throw t=!1,this._$EM(),s}t&&this._$AE(s)}willUpdate(t){}_$AE(t){this._$EO?.forEach((t=>t.hostUpdated?.())),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t)}_$EM(){this._$AL=new Map,this.isUpdatePending=!1}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$ES}shouldUpdate(t){return!0}update(t){this._$Eq&&=this._$Eq.forEach((t=>this._$ET(t,this[t]))),this._$EM()}updated(t){}firstUpdated(t){}}y.elementStyles=[],y.shadowRootOptions={mode:\"open\"},y[d(\"elementProperties\")]=new Map,y[d(\"finalized\")]=new Map,p?.({ReactiveElement:y}),(a.reactiveElementVersions??=[]).push(\"2.1.1\");export{y as ReactiveElement,s as adoptStyles,u as defaultConverter,t as getCompatibleStyle,f as notEqual};\n//# sourceMappingURL=reactive-element.js.map\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst t=globalThis,i=t.trustedTypes,s=i?i.createPolicy(\"lit-html\",{createHTML:t=>t}):void 0,e=\"$lit$\",h=`lit$${Math.random().toFixed(9).slice(2)}$`,o=\"?\"+h,n=`<${o}>`,r=document,l=()=>r.createComment(\"\"),c=t=>null===t||\"object\"!=typeof t&&\"function\"!=typeof t,a=Array.isArray,u=t=>a(t)||\"function\"==typeof t?.[Symbol.iterator],d=\"[ \\t\\n\\f\\r]\",f=/<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g,v=/-->/g,_=/>/g,m=RegExp(`>|${d}(?:([^\\\\s\"'>=/]+)(${d}*=${d}*(?:[^ \\t\\n\\f\\r\"'\\`<>=]|(\"|')|))|$)`,\"g\"),p=/'/g,g=/\"/g,$=/^(?:script|style|textarea|title)$/i,y=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),x=y(1),b=y(2),w=y(3),T=Symbol.for(\"lit-noChange\"),E=Symbol.for(\"lit-nothing\"),A=new WeakMap,C=r.createTreeWalker(r,129);function P(t,i){if(!a(t)||!t.hasOwnProperty(\"raw\"))throw Error(\"invalid template strings array\");return void 0!==s?s.createHTML(i):i}const V=(t,i)=>{const s=t.length-1,o=[];let r,l=2===i?\"<svg>\":3===i?\"<math>\":\"\",c=f;for(let i=0;i<s;i++){const s=t[i];let a,u,d=-1,y=0;for(;y<s.length&&(c.lastIndex=y,u=c.exec(s),null!==u);)y=c.lastIndex,c===f?\"!--\"===u[1]?c=v:void 0!==u[1]?c=_:void 0!==u[2]?($.test(u[2])&&(r=RegExp(\"</\"+u[2],\"g\")),c=m):void 0!==u[3]&&(c=m):c===m?\">\"===u[0]?(c=r??f,d=-1):void 0===u[1]?d=-2:(d=c.lastIndex-u[2].length,a=u[1],c=void 0===u[3]?m:'\"'===u[3]?g:p):c===g||c===p?c=m:c===v||c===_?c=f:(c=m,r=void 0);const x=c===m&&t[i+1].startsWith(\"/>\")?\" \":\"\";l+=c===f?s+n:d>=0?(o.push(a),s.slice(0,d)+e+s.slice(d)+h+x):s+h+(-2===d?i:x)}return[P(t,l+(t[s]||\"<?>\")+(2===i?\"</svg>\":3===i?\"</math>\":\"\")),o]};class N{constructor({strings:t,_$litType$:s},n){let r;this.parts=[];let c=0,a=0;const u=t.length-1,d=this.parts,[f,v]=V(t,s);if(this.el=N.createElement(f,n),C.currentNode=this.el.content,2===s||3===s){const t=this.el.content.firstChild;t.replaceWith(...t.childNodes)}for(;null!==(r=C.nextNode())&&d.length<u;){if(1===r.nodeType){if(r.hasAttributes())for(const t of r.getAttributeNames())if(t.endsWith(e)){const i=v[a++],s=r.getAttribute(t).split(h),e=/([.?@])?(.*)/.exec(i);d.push({type:1,index:c,name:e[2],strings:s,ctor:\".\"===e[1]?H:\"?\"===e[1]?I:\"@\"===e[1]?L:k}),r.removeAttribute(t)}else t.startsWith(h)&&(d.push({type:6,index:c}),r.removeAttribute(t));if($.test(r.tagName)){const t=r.textContent.split(h),s=t.length-1;if(s>0){r.textContent=i?i.emptyScript:\"\";for(let i=0;i<s;i++)r.append(t[i],l()),C.nextNode(),d.push({type:2,index:++c});r.append(t[s],l())}}}else if(8===r.nodeType)if(r.data===o)d.push({type:2,index:c});else{let t=-1;for(;-1!==(t=r.data.indexOf(h,t+1));)d.push({type:7,index:c}),t+=h.length-1}c++}}static createElement(t,i){const s=r.createElement(\"template\");return s.innerHTML=t,s}}function S(t,i,s=t,e){if(i===T)return i;let h=void 0!==e?s._$Co?.[e]:s._$Cl;const o=c(i)?void 0:i._$litDirective$;return h?.constructor!==o&&(h?._$AO?.(!1),void 0===o?h=void 0:(h=new o(t),h._$AT(t,s,e)),void 0!==e?(s._$Co??=[])[e]=h:s._$Cl=h),void 0!==h&&(i=S(t,h._$AS(t,i.values),h,e)),i}class M{constructor(t,i){this._$AV=[],this._$AN=void 0,this._$AD=t,this._$AM=i}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(t){const{el:{content:i},parts:s}=this._$AD,e=(t?.creationScope??r).importNode(i,!0);C.currentNode=e;let h=C.nextNode(),o=0,n=0,l=s[0];for(;void 0!==l;){if(o===l.index){let i;2===l.type?i=new R(h,h.nextSibling,this,t):1===l.type?i=new l.ctor(h,l.name,l.strings,this,t):6===l.type&&(i=new z(h,this,t)),this._$AV.push(i),l=s[++n]}o!==l?.index&&(h=C.nextNode(),o++)}return C.currentNode=r,e}p(t){let i=0;for(const s of this._$AV)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++}}class R{get _$AU(){return this._$AM?._$AU??this._$Cv}constructor(t,i,s,e){this.type=2,this._$AH=E,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cv=e?.isConnected??!0}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===t?.nodeType&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=S(this,t,i),c(t)?t===E||null==t||\"\"===t?(this._$AH!==E&&this._$AR(),this._$AH=E):t!==this._$AH&&t!==T&&this._(t):void 0!==t._$litType$?this.$(t):void 0!==t.nodeType?this.T(t):u(t)?this.k(t):this._(t)}O(t){return this._$AA.parentNode.insertBefore(t,this._$AB)}T(t){this._$AH!==t&&(this._$AR(),this._$AH=this.O(t))}_(t){this._$AH!==E&&c(this._$AH)?this._$AA.nextSibling.data=t:this.T(r.createTextNode(t)),this._$AH=t}$(t){const{values:i,_$litType$:s}=t,e=\"number\"==typeof s?this._$AC(t):(void 0===s.el&&(s.el=N.createElement(P(s.h,s.h[0]),this.options)),s);if(this._$AH?._$AD===e)this._$AH.p(i);else{const t=new M(e,this),s=t.u(this.options);t.p(i),this.T(s),this._$AH=t}}_$AC(t){let i=A.get(t.strings);return void 0===i&&A.set(t.strings,i=new N(t)),i}k(t){a(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const h of t)e===i.length?i.push(s=new R(this.O(l()),this.O(l()),this,this.options)):s=i[e],s._$AI(h),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e)}_$AR(t=this._$AA.nextSibling,i){for(this._$AP?.(!1,!0,i);t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i}}setConnected(t){void 0===this._$AM&&(this._$Cv=t,this._$AP?.(t))}}class k{get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}constructor(t,i,s,e,h){this.type=1,this._$AH=E,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=h,s.length>2||\"\"!==s[0]||\"\"!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=E}_$AI(t,i=this,s,e){const h=this.strings;let o=!1;if(void 0===h)t=S(this,t,i,0),o=!c(t)||t!==this._$AH&&t!==T,o&&(this._$AH=t);else{const e=t;let n,r;for(t=h[0],n=0;n<h.length-1;n++)r=S(this,e[s+n],i,n),r===T&&(r=this._$AH[n]),o||=!c(r)||r!==this._$AH[n],r===E?t=E:t!==E&&(t+=(r??\"\")+h[n+1]),this._$AH[n]=r}o&&!e&&this.j(t)}j(t){t===E?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,t??\"\")}}class H extends k{constructor(){super(...arguments),this.type=3}j(t){this.element[this.name]=t===E?void 0:t}}class I extends k{constructor(){super(...arguments),this.type=4}j(t){this.element.toggleAttribute(this.name,!!t&&t!==E)}}class L extends k{constructor(t,i,s,e,h){super(t,i,s,e,h),this.type=5}_$AI(t,i=this){if((t=S(this,t,i,0)??E)===T)return;const s=this._$AH,e=t===E&&s!==E||t.capture!==s.capture||t.once!==s.once||t.passive!==s.passive,h=t!==E&&(s===E||e);e&&this.element.removeEventListener(this.name,this,s),h&&this.element.addEventListener(this.name,this,t),this._$AH=t}handleEvent(t){\"function\"==typeof this._$AH?this._$AH.call(this.options?.host??this.element,t):this._$AH.handleEvent(t)}}class z{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s}get _$AU(){return this._$AM._$AU}_$AI(t){S(this,t)}}const Z={M:e,P:h,A:o,C:1,L:V,R:M,D:u,V:S,I:R,H:k,N:I,U:L,B:H,F:z},j=t.litHtmlPolyfillSupport;j?.(N,R),(t.litHtmlVersions??=[]).push(\"3.3.1\");const B=(t,i,s)=>{const e=s?.renderBefore??i;let h=e._$litPart$;if(void 0===h){const t=s?.renderBefore??null;e._$litPart$=h=new R(i.insertBefore(l(),t),t,void 0,s??{})}return h._$AI(t),h};export{Z as _$LH,x as html,w as mathml,T as noChange,E as nothing,B as render,b as svg};\n//# sourceMappingURL=lit-html.js.map\n","import{ReactiveElement as t}from\"@lit/reactive-element\";export*from\"@lit/reactive-element\";import{render as e,noChange as r}from\"lit-html\";export*from\"lit-html\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */const s=globalThis;class i extends t{constructor(){super(...arguments),this.renderOptions={host:this},this._$Do=void 0}createRenderRoot(){const t=super.createRenderRoot();return this.renderOptions.renderBefore??=t.firstChild,t}update(t){const r=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Do=e(r,this.renderRoot,this.renderOptions)}connectedCallback(){super.connectedCallback(),this._$Do?.setConnected(!0)}disconnectedCallback(){super.disconnectedCallback(),this._$Do?.setConnected(!1)}render(){return r}}i._$litElement$=!0,i[\"finalized\"]=!0,s.litElementHydrateSupport?.({LitElement:i});const o=s.litElementPolyfillSupport;o?.({LitElement:i});const n={_$AK:(t,e,r)=>{t._$AK(e,r)},_$AL:t=>t._$AL};(s.litElementVersions??=[]).push(\"4.2.1\");export{i as LitElement,n as _$LE};\n//# sourceMappingURL=lit-element.js.map\n","import{defaultConverter as t,notEqual as e}from\"../reactive-element.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */const o={attribute:!0,type:String,converter:t,reflect:!1,hasChanged:e},r=(t=o,e,r)=>{const{kind:n,metadata:i}=r;let s=globalThis.litPropertyMetadata.get(i);if(void 0===s&&globalThis.litPropertyMetadata.set(i,s=new Map),\"setter\"===n&&((t=Object.create(t)).wrapped=!0),s.set(r.name,t),\"accessor\"===n){const{name:o}=r;return{set(r){const n=e.get.call(this);e.set.call(this,r),this.requestUpdate(o,n,t)},init(e){return void 0!==e&&this.C(o,void 0,t,e),e}}}if(\"setter\"===n){const{name:o}=r;return function(r){const n=this[o];e.call(this,r),this.requestUpdate(o,n,t)}}throw Error(\"Unsupported decorator location: \"+n)};function n(t){return(e,o)=>\"object\"==typeof o?r(t,e,o):((t,e,o)=>{const r=e.hasOwnProperty(o);return e.constructor.createProperty(o,t),r?Object.getOwnPropertyDescriptor(e,o):void 0})(t,e,o)}export{n as property,r as standardProperty};\n//# sourceMappingURL=property.js.map\n","import{property as t}from\"./property.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */function r(r){return t({...r,state:!0,attribute:!1})}export{r as state};\n//# sourceMappingURL=state.js.map\n","import { HomeAssistant } from '../types/index';\nimport { TimerData } from './Timer';\n\n/**\n * StandardTimerService - Handles Home Assistant native timer entities\n * Focused on timer.* domain entities with standard HA timer behavior\n */\nexport class StandardTimerService {\n  /**\n   * Handles standard HA timer data extraction\n   * @param entityId - Timer entity ID\n   * @param entity - Entity state object\n   * @param parseDuration - Duration parsing utility function\n   * @returns TimerData for standard timer\n   */\n  static getStandardTimerData(\n    entityId: string, \n    entity: any, \n    parseDuration: (duration: any) => number\n  ): TimerData | null {\n    const state = entity.state;\n    const attributes = entity.attributes;\n\n    // Timer states: idle, active, paused\n    const isActive = state === 'active';\n    const isPaused = state === 'paused';\n    const isIdle = state === 'idle';\n\n    // Get duration from attributes (in seconds or HH:MM:SS format)\n    let duration = 0;\n    if (attributes.duration) {\n      duration = parseDuration(attributes.duration);\n    }\n\n    // Calculate remaining time\n    let remaining = 0;\n    let finishesAt: Date | null = null;\n\n    if (isActive || isPaused) {\n      if (attributes.finishes_at) {\n        // Parse finishes_at timestamp\n        finishesAt = new Date(attributes.finishes_at);\n        if (!isNaN(finishesAt.getTime())) {\n          remaining = Math.max(0, Math.floor((finishesAt.getTime() - Date.now()) / 1000));\n        }\n      } else if (attributes.remaining) {\n        // Fallback to remaining attribute if available\n        remaining = parseDuration(attributes.remaining);\n      }\n    }\n\n    // Calculate progress (0-100)\n    let progress = 0;\n    if (duration > 0) {\n      if (isIdle) {\n        progress = 0;\n      } else {\n        const elapsed = duration - remaining;\n        progress = Math.min(100, Math.max(0, (elapsed / duration) * 100));\n      }\n    }\n\n    return {\n      isActive,\n      isPaused,\n      duration,\n      remaining,\n      finishesAt,\n      progress,\n      isAlexaTimer: false\n    };\n  }\n}\n","import { HomeAssistant } from '../types/index';\nimport { TimerData } from './Timer';\n\n/**\n * AlexaTimerService - Handles Amazon Alexa Media Player timer entities\n * Focused on sensor.*_next_timer entities with rich Alexa timer attributes\n */\nexport class AlexaTimerService {\n  // Per-entity cache to track Alexa timer IDs and transitions\n  private static alexaIdCache: Map<string, { finishedWhileActiveId?: string }> = new Map();\n\n  /**\n   * Handles Alexa timer data extraction\n   * @param entityId - Alexa timer entity ID\n   * @param entity - Entity state object\n   * @param hass - Home Assistant object\n   * @param isISOTimestamp - ISO timestamp validation function\n   * @param parseDuration - Duration parsing utility function\n   * @returns TimerData for Alexa timer\n   */\n  static getAlexaTimerData(\n    entityId: string, \n    entity: any, \n    hass: HomeAssistant,\n    isISOTimestamp: (str: string) => boolean,\n    parseDuration: (duration: any) => number\n  ): TimerData | null {\n    const { state, attributes } = entity;\n\n    // 1) Parse rich JSON first (status authority comes from attributes, not entity.state)\n    const activeTimers = this.parseJson(attributes.sorted_active) ?? [];\n    const allTimers    = this.parseJson(attributes.sorted_all)    ?? [];\n    const totalActive: number = (attributes.total_active as number) ?? activeTimers.length ?? 0;\n    const totalAll: number    = (attributes.total_all as number)    ?? allTimers.length    ?? 0;\n\n    // Build quick lookups keyed by the ID (handles both tuple and object formats)\n    const activeMap = new Map<string, any>();\n    for (const t of activeTimers) {\n      const entry = this.extractTimerEntry(t);\n      if (entry) {\n        activeMap.set(entry.id, entry.data);\n      }\n    }\n    const allMap = new Map<string, any>();\n    for (const t of allTimers) {\n      const entry = this.extractTimerEntry(t);\n      if (entry) {\n        allMap.set(entry.id, entry.data);\n      }\n    }\n\n    // ID-based finished tracking: if an active timer's triggerTime has passed, remember that ID\n    const nowTs = Date.now();\n    let cache = this.alexaIdCache.get(entityId);\n    if (!cache) { cache = {}; this.alexaIdCache.set(entityId, cache); }\n    // Determine candidates that have finished but are still listed as active\n    const finishedActiveIds: Array<{ id: string; trig: number }> = [];\n    for (const [id, data] of activeMap.entries()) {\n      const trig = typeof data?.triggerTime === 'number' ? data.triggerTime : 0;\n      if (trig && trig <= nowTs) {\n        finishedActiveIds.push({ id, trig });\n      }\n    }\n    if (finishedActiveIds.length > 0) {\n      // Choose the one that should have finished earliest\n      finishedActiveIds.sort((a, b) => a.trig - b.trig);\n      cache.finishedWhileActiveId = finishedActiveIds[0].id;\n    } else if (cache.finishedWhileActiveId && !activeMap.has(cache.finishedWhileActiveId)) {\n      // Clear once the finished item leaves the active list\n      delete cache.finishedWhileActiveId;\n    }\n\n    // Determine state: Active > Paused > Finished > None\n    let isActive = false;\n    let isPaused = false;\n    let isFinished = false;\n    let primaryTimer: any | null = null;\n    let primaryId: string | undefined;\n\n    if (totalActive > 0 && activeTimers.length > 0) {\n      // Prefer the ID we know just finished while still listed as active\n      if (cache.finishedWhileActiveId && activeMap.has(cache.finishedWhileActiveId)) {\n        primaryId = cache.finishedWhileActiveId;\n        primaryTimer = activeMap.get(primaryId) ?? null;\n        isActive = !!primaryTimer;\n        isFinished = true; // enforce finished view for this ID\n      } else {\n        // Choose the active timer (prefer the one with shortest remainingTime)\n        if (activeTimers.length === 1) {\n          const entry = this.extractTimerEntry(activeTimers[0]);\n          primaryId = entry?.id;\n          primaryTimer = entry?.data ?? null;\n        } else {\n          let bestId: string | undefined;\n          let best: any = null;\n          let shortest = Number.POSITIVE_INFINITY;\n          for (const t of activeTimers) {\n            const entry = this.extractTimerEntry(t);\n            if (entry && typeof entry.data?.remainingTime === 'number' && entry.data.remainingTime < shortest) {\n              shortest = entry.data.remainingTime;\n              best = entry.data;\n              bestId = entry.id;\n            }\n          }\n          primaryId = bestId;\n          primaryTimer = best;\n        }\n        isActive = !!primaryTimer;\n        // Edge: if the selected active timer is actually past its trigger, mark finished\n        if (isActive && primaryTimer && typeof primaryTimer.triggerTime === 'number' && primaryTimer.triggerTime <= nowTs) {\n          isFinished = true;\n          cache.finishedWhileActiveId = primaryId; // remember which one\n        }\n      }\n    } else if (totalAll > 0 && allTimers.length > 0) {\n      // No active timers: prefer a paused timer if any; do not show finished based solely on sorted_all\n      // Find the most recently updated paused timer\n      let mostRecentPaused: any = null;\n      let latest = -Infinity;\n      for (const [id, data] of allMap.entries()) {\n        if (data?.status === 'PAUSED') {\n          const updated = typeof data.lastUpdatedDate === 'number' ? data.lastUpdatedDate : -Infinity;\n          if (updated > latest) {\n            latest = updated;\n            mostRecentPaused = data;\n            primaryId = id;\n          }\n        }\n      }\n      if (mostRecentPaused) {\n        primaryTimer = mostRecentPaused;\n        isPaused = true;\n      }\n    }\n\n    // 2) Compute duration/remaining/progress, preferring rich data; fallback to legacy entity.state\n    let remaining = 0;\n    let duration = 0;\n    let finishesAt: Date | null = null;\n    let progress = 0;\n\n    if (primaryTimer) {\n      const now = Date.now();\n      const rtMs = typeof primaryTimer.remainingTime === 'number' ? primaryTimer.remainingTime : 0; // ms\n      const odMs = typeof primaryTimer.originalDurationInMillis === 'number' ? primaryTimer.originalDurationInMillis : 0; // ms\n      const trig = typeof primaryTimer.triggerTime === 'number' ? primaryTimer.triggerTime : 0; // epoch ms\n\n      duration = Math.max(0, Math.floor(odMs / 1000));\n\n    if (isActive) {\n        // Prefer triggerTime for live ticking\n        if (trig && trig > now) {\n          remaining = Math.max(0, Math.floor((trig - now) / 1000));\n          finishesAt = new Date(trig);\n        } else {\n          // Fallback to remainingTime snapshot\n          remaining = Math.max(0, Math.floor(rtMs / 1000));\n          if (remaining > 0) finishesAt = new Date(now + remaining * 1000);\n        }\n\n        // If we've passed triggerTime or remaining is zero, mark as finished, but keep active until it leaves sorted_active\n        if ((trig && trig <= now) || remaining <= 0 || (primaryTimer.status === 'OFF' && rtMs === 0)) {\n          remaining = 0;\n          finishesAt = null;\n          isFinished = true;\n        }\n    } else if (isPaused) {\n        // While paused, trust remainingTime snapshot and do not set finishesAt\n        remaining = Math.max(0, Math.floor(rtMs / 1000));\n        finishesAt = null;\n      } else {\n        // Idle/none selected in no-active case: leave remaining at 0\n        remaining = Math.max(0, Math.floor(rtMs / 1000));\n        finishesAt = null;\n      }\n\n    if (duration > 0) {\n        const elapsed = Math.max(0, duration - remaining);\n        progress = Math.min(100, Math.max(0, (elapsed / duration) * 100));\n        // If still in active list but progress reached 100, enforce finished view\n        if (isActive && progress >= 100) {\n          remaining = 0;\n          isFinished = true;\n        }\n      }\n    } else {\n      // Legacy fallback for remaining/duration when no rich item is available\n      if (state && state !== 'unavailable' && state !== 'unknown') {\n        if (isISOTimestamp(state)) {\n          finishesAt = new Date(state);\n          if (!isNaN(finishesAt.getTime())) {\n            remaining = Math.max(0, Math.floor((finishesAt.getTime() - Date.now()) / 1000));\n          }\n        } else if (!isNaN(parseFloat(state))) {\n          remaining = Math.max(0, parseFloat(state));\n        } else if (typeof state === 'string' && state.includes(':')) {\n          remaining = parseDuration(state);\n        }\n      }\n\n      if (attributes.original_duration) {\n        duration = parseDuration(attributes.original_duration);\n      } else if (attributes.duration) {\n        duration = parseDuration(attributes.duration);\n      } else if (finishesAt && entity.last_changed) {\n        const start = new Date(entity.last_changed).getTime();\n        const end   = finishesAt.getTime();\n        if (!isNaN(start) && end > start) duration = Math.floor((end - start) / 1000);\n      }\n\n      if (duration > 0) {\n        const elapsed = duration - remaining;\n        progress = Math.min(100, Math.max(0, (elapsed / duration) * 100));\n      }\n    }\n\n    // Note: Do not collapse to \"No timers\" based solely on a dismissed flag.\n    // We'll show \"timer complete\" as long as a finished timer exists in sorted_all.\n\n    // 3) Label selection (prefer label from primary timer)\n    // Use extractTimerLabel to handle both timerLabel and label fields\n    let label: string | undefined = this.extractTimerLabel(primaryTimer);\n    if (!label && activeTimers.length > 0) {\n      const firstActive = this.extractTimerEntry(activeTimers[0]);\n      label = this.extractTimerLabel(firstActive?.data);\n    }\n    if (!label && allTimers.length > 0) {\n      const firstAll = this.extractTimerEntry(allTimers[0]);\n      label = this.extractTimerLabel(firstAll?.data);\n    }\n\n    return {\n      isActive,\n    isPaused,\n      duration,\n      remaining,\n      finishesAt,\n    progress,\n    finished: isFinished,\n      isAlexaTimer: true,\n      alexaDevice: this.extractAlexaDevice(entityId, attributes),\n      timerLabel: label ?? this.extractAlexaDevice(entityId, attributes),\n    timerStatus: isPaused ? 'PAUSED' : (isActive ? 'ON' : 'OFF'),\n      userDefinedLabel: label,\n    };\n  }\n\n  /**\n   * Legacy fallback for Alexa timer parsing (when rich attributes unavailable)\n   * @param entityId - Entity ID\n   * @param entity - Entity object\n   * @param state - Entity state\n   * @param attributes - Entity attributes\n   * @param isISOTimestamp - ISO timestamp validation function\n   * @param parseDuration - Duration parsing utility function\n   * @returns TimerData object\n   */\n  static parseLegacyAlexaTimer(\n    entityId: string, \n    entity: any, \n    state: any, \n    attributes: any,\n    isISOTimestamp: (str: string) => boolean,\n    parseDuration: (duration: any) => number\n  ): TimerData | null {\n    // Alexa timers might be stored as timestamps or duration strings\n    let remaining = 0;\n    let duration = 0;\n    let finishesAt: Date | null = null;\n    let isActive = false;\n    \n    // Handle different Alexa timer formats\n    if (state && state !== 'unavailable' && state !== 'unknown') {\n      // Case 1: State is a timestamp (end time)\n      if (isISOTimestamp(state)) {\n        finishesAt = new Date(state);\n        if (!isNaN(finishesAt.getTime())) {\n          const now = Date.now();\n          remaining = Math.max(0, Math.floor((finishesAt.getTime() - now) / 1000));\n          isActive = remaining > 0;\n        }\n      }\n      // Case 2: State is duration in seconds\n      else if (!isNaN(parseFloat(state))) {\n        remaining = Math.max(0, parseFloat(state));\n        isActive = remaining > 0;\n      }\n      // Case 3: State is duration string (HH:MM:SS)\n      else if (typeof state === 'string' && state.includes(':')) {\n        remaining = parseDuration(state);\n        isActive = remaining > 0;\n      }\n    }\n\n    // Try to get duration from attributes\n    let hasOriginalDuration = false;\n    if (attributes.original_duration) {\n      duration = parseDuration(attributes.original_duration);\n      hasOriginalDuration = true;\n    } else if (attributes.duration) {\n      duration = parseDuration(attributes.duration);\n      hasOriginalDuration = true;\n    } else if (finishesAt && entity.last_changed) {\n      // Try to calculate duration from finishesAt and last_changed (when timer was set)\n      const startTime = new Date(entity.last_changed).getTime();\n      const endTime = finishesAt.getTime();\n      if (!isNaN(startTime) && endTime > startTime) {\n        duration = Math.floor((endTime - startTime) / 1000);\n        hasOriginalDuration = true;\n      }\n    }\n    \n    if (!hasOriginalDuration) {\n      // If no original duration, we can't calculate meaningful progress\n      // For display purposes, we'll use remaining as duration, but handle progress specially\n      duration = remaining > 0 ? remaining : 0;\n      hasOriginalDuration = false;\n    }\n\n    // Calculate progress - IMPROVED LOGIC based on timer-bar-card approach\n    let progress = 0;\n    if (hasOriginalDuration && duration > 0) {\n      // We have a real original duration, calculate normal progress\n      if (isActive && remaining >= 0) {\n        const elapsed = duration - remaining;\n        progress = Math.min(100, Math.max(0, (elapsed / duration) * 100));\n      } else if (remaining === 0 && duration > 0) {\n        progress = 100; // Timer finished (only if we had a real duration)\n      }\n    } else {\n      // No original duration available - handle differently for better accuracy\n      if (isActive && remaining > 0) {\n        // For Alexa timers without original duration, we need to be smarter\n        // Option 1: Use entity's last_changed to estimate start time\n        const lastChanged = entity.last_changed ? new Date(entity.last_changed).getTime() : Date.now();\n        const now = Date.now();\n        const timeSinceChanged = (now - lastChanged) / 1000; // seconds\n        \n        // If the timer was recently updated, we can estimate duration\n        if (timeSinceChanged < remaining) {\n          const estimatedDuration = remaining + timeSinceChanged;\n          const elapsed = timeSinceChanged;\n          progress = Math.min(100, Math.max(0, (elapsed / estimatedDuration) * 100));\n        } else {\n          // Fallback: start progress from 0% for active timers without duration\n          // This prevents the \"75%\" issue you're experiencing\n          progress = 0;\n        }\n      } else {\n        // No active timer OR no remaining time\n        // Check if this is actually a \"no timer\" state vs \"timer finished\" state\n        if (state === 'unavailable' || state === 'unknown' || state === 'none' || state === null || state === '') {\n          progress = 0; // No timer present - show empty progress\n        } else if (remaining === 0 && (isActive === false)) {\n          // This could be a finished timer, but without original duration we can't be sure\n          // Default to empty progress to avoid showing full progress incorrectly\n          progress = 0;\n        } else {\n          progress = 0; // Default case\n        }\n      }\n    }\n\n    // Extract Alexa-specific info using legacy methods\n    const alexaDevice = this.extractAlexaDevice(entityId, attributes);\n    const timerLabel = attributes.friendly_name || attributes.timer_label || this.formatAlexaTimerName(entityId);\n\n    return {\n      isActive,\n      isPaused: false, // Alexa timers don't typically pause in legacy mode\n      duration,\n      remaining,\n      finishesAt,\n      progress,\n      isAlexaTimer: true,\n      alexaDevice,\n      timerLabel,\n      timerStatus: isActive ? \"ON\" : \"OFF\",\n      userDefinedLabel: undefined // Not available in legacy mode\n    };\n  }\n\n  /**\n   * AUTO-DISCOVERY: Attempts to find Alexa timer entities in Home Assistant\n   * @param hass - Home Assistant object\n   * @param isAlexaTimer - Alexa timer detection function\n   * @param getTimerData - Timer data extraction function\n   * @returns string[] - Array of potential Alexa timer entity IDs\n   */\n  static discoverAlexaTimers(\n    hass: HomeAssistant,\n    isAlexaTimer: (entityId: string) => boolean,\n    getTimerData: (entityId: string, hass: HomeAssistant) => TimerData | null\n  ): string[] {\n    if (!hass || !hass.states) return [];\n    \n    const alexaTimers: string[] = [];\n    \n    for (const entityId in hass.states) {\n      if (isAlexaTimer(entityId)) {\n        const entity = hass.states[entityId];\n        // Include if rich attributes indicate any timers, regardless of entity.state\n        const attributes = entity.attributes || {};\n        const activeTimers = this.parseJson(attributes.sorted_active) ?? [];\n        const allTimers    = this.parseJson(attributes.sorted_all)    ?? [];\n\n        const hasActive = Array.isArray(activeTimers) && activeTimers.length > 0;\n        let hasPaused = false;\n        if (!hasActive && Array.isArray(allTimers) && allTimers.length > 0) {\n          for (const t of allTimers) {\n            const entry = this.extractTimerEntry(t);\n            const data = entry?.data;\n            if (data && data.status === 'PAUSED' && typeof data.remainingTime === 'number' && data.remainingTime > 0) {\n              hasPaused = true;\n              break;\n            }\n          }\n        }\n\n        if (hasActive || hasPaused) {\n          alexaTimers.push(entityId);\n          continue;\n        }\n        // Fallback: compute and include only if active or paused according to parser\n        const timerData = getTimerData(entityId, hass);\n        if (timerData && (timerData.isActive || timerData.isPaused)) {\n          alexaTimers.push(entityId);\n        }\n      }\n    }\n    \n    return alexaTimers;\n  }\n\n  /**\n   * Helper method to parse JSON strings/arrays\n   */\n  private static parseJson(src: any): any[] | null {\n    if (Array.isArray(src)) return src;\n    if (typeof src === 'string') { \n      try { \n        return JSON.parse(src); \n      } catch {} \n    }\n    return null;\n  }\n\n  /**\n   * Helper to extract id and data from timer entry\n   * Handles both old tuple format [id, data] and new object format {id, ...data}\n   * @param entry - Timer entry (either tuple or object)\n   * @returns {id, data} or null if invalid\n   */\n  private static extractTimerEntry(entry: any): { id: string; data: any } | null {\n    // New object format: {id, timerLabel, status, remainingTime, ...}\n    if (entry && typeof entry === 'object' && !Array.isArray(entry) && entry.id) {\n      return { id: String(entry.id), data: entry };\n    }\n    // Old tuple format: [id, {timerLabel, status, remainingTime, ...}]\n    if (Array.isArray(entry) && entry.length >= 2 && entry[0] && entry[1]) {\n      return { id: String(entry[0]), data: entry[1] };\n    }\n    return null;\n  }\n\n  /**\n   * Helper to extract timer label from timer data\n   * Checks timerLabel first (sorted_* format), then label (brief format)\n   * @param data - Timer data object\n   * @returns Timer label or undefined\n   */\n  private static extractTimerLabel(data: any): string | undefined {\n    if (!data) return undefined;\n    // timerLabel is used in sorted_active/sorted_all\n    if (data.timerLabel) return data.timerLabel;\n    // label is used in brief.active/brief.all (generic resolved label)\n    if (data.label) return data.label;\n    return undefined;\n  }\n\n  /**\n   * Extracts Alexa device name from entity ID or attributes\n   * @param entityId - Entity ID\n   * @param attributes - Entity attributes\n   * @returns string - Device name\n   */\n  private static extractAlexaDevice(entityId: string, attributes: any): string {\n    // First try to clean up friendly_name if it exists\n    if (attributes.friendly_name) {\n      let deviceName = attributes.friendly_name;\n      \n      // Remove common timer-related suffixes that clutter the display\n      deviceName = deviceName\n        .replace(/\\s*next\\s*timer$/i, '')\n        .replace(/\\s*timer$/i, '')\n        .replace(/\\s*echo\\s*timer$/i, '')\n        .replace(/\\s*alexa\\s*timer$/i, '')\n        .trim();\n      \n      if (deviceName) return deviceName;\n    }\n\n    // Try to extract from entity ID pattern: sensor.device_name_next_timer\n    if (entityId.includes('_next_timer')) {\n      const devicePart = entityId\n        .replace(/^sensor\\./, '')\n        .replace(/_next_timer$/, '')\n        .replace(/_/g, ' ')\n        .replace(/\\b\\w/g, l => l.toUpperCase());\n      \n      if (devicePart) return devicePart;\n    }\n    \n    // Try from other attributes\n    if (attributes.device_name) return attributes.device_name;\n    if (attributes.device) return attributes.device;\n    \n    // Fallback\n    return 'Alexa Device';\n  }\n\n  /**\n   * Formats Alexa timer name from entity ID\n   * @param entityId - Entity ID\n   * @returns string - Formatted name\n   */\n  private static formatAlexaTimerName(entityId: string): string {\n    return entityId\n      .replace(/^sensor\\./, '')\n      .replace(/_next_timer$/, '')\n      .replace(/_timer$/, '')\n      .replace(/_/g, ' ')\n      .replace(/\\b\\w/g, l => l.toUpperCase());\n  }\n}\n","import { HomeAssistant } from '../types/index';\nimport { TimerData } from './Timer';\n\n/**\n * GoogleTimerService - Handles Google Home custom component timer entities\n * Implements timer ID level tracking similar to Alexa for Google Home timers\n * Based on ha-google-home integration: https://github.com/leikoilja/ha-google-home\n */\nexport class GoogleTimerService {\n  \n  // Cache for Google timer ID-based finished state persistence and paused snapshots\n  private static googleIdCache = new Map<string, {\n    finishedTimerId?: string;\n    lastDuration?: number;\n    lastLabel?: string;\n    pausedSnapshots?: Map<string, { remaining: number; pausedAt: number; wasActive?: boolean }>;\n  }>();\n\n  /**\n   * Handles Google Home timer data extraction with timer ID tracking.\n   * @param entityId - Google Home timer entity ID\n   * @param entity - Entity state object\n   * @param hass - Home Assistant object\n   * @param parseDuration - Duration parsing utility function\n   * @returns TimerData for the primary Google Home timer\n   */\n  static getGoogleTimerData(\n    entityId: string,\n    entity: any,\n    hass: HomeAssistant,\n    parseDuration: (duration: any) => number\n  ): TimerData | null {\n    const { state, attributes } = entity;\n\n    // The ha-google-home integration stores timers in a list attribute\n    const allTimers = attributes.timers || [];\n\n    if (!Array.isArray(allTimers) || allTimers.length === 0) {\n      // If timers array is completely empty, clear any cached finished timer\n      // This handles the case when a ringing timer gets dismissed\n      const entityCache = this.googleIdCache.get(entityId);\n      if (entityCache?.finishedTimerId) {\n        // Clear the finished timer cache since no timers exist anymore\n        delete entityCache.finishedTimerId;\n        delete entityCache.lastDuration;\n        delete entityCache.lastLabel;\n      }\n      \n      // Return \"no timers\" state instead of null for auto-discovery compatibility\n      return {\n        isActive: false,\n        isPaused: false,\n        duration: 0,\n        remaining: 0,\n        finishesAt: null,\n        progress: 0,\n        finished: false,\n        isGoogleTimer: true,\n        userDefinedLabel: undefined,\n        googleTimerId: undefined,\n        googleTimerStatus: 'none',\n      };\n    }\n\n    // Create maps for active and all timers with timer_id as key\n    const activeTimers = new Map<string, any>();\n    const allTimersMap = new Map<string, any>();\n\n    for (const timer of allTimers) {\n      if (timer.timer_id) {\n        allTimersMap.set(String(timer.timer_id), timer);\n        if (timer.status === 'set' || timer.status === 'ringing') {\n          activeTimers.set(String(timer.timer_id), timer);\n        }\n      }\n    }\n\n    // Timer ID level tracking - detect finished timers\n    const now = Date.now() / 1000; // Convert to seconds to match fire_time\n    let entityCache = this.googleIdCache.get(entityId);\n    if (!entityCache) {\n      entityCache = {};\n      this.googleIdCache.set(entityId, entityCache);\n    }\n\n    // Check for finished timers (timers that were active but now missing/expired/ringing)\n    const finishedCandidates: Array<{id: string, fireTime: number, timer: any}> = [];\n    \n    // Check active timers that have passed their fire_time\n    for (const [timerId, timer] of activeTimers.entries()) {\n      if (timer.fire_time && timer.fire_time <= now && timer.status !== 'ringing') {\n        finishedCandidates.push({id: timerId, fireTime: timer.fire_time, timer});\n      }\n    }\n    \n    // Check for ringing timers (they are finished/completed)\n    for (const timer of allTimers) {\n      if (timer.timer_id && timer.status === 'ringing') {\n        const timerId = String(timer.timer_id);\n        const fireTime = timer.fire_time || now - 1; // Use fire_time or current time if missing\n        finishedCandidates.push({id: timerId, fireTime, timer});\n      }\n    }\n\n    // Sort by fire time and pick the most recently finished\n    if (finishedCandidates.length > 0) {\n      finishedCandidates.sort((a, b) => b.fireTime - a.fireTime);\n      entityCache.finishedTimerId = finishedCandidates[0].id;\n      const finishedTimer = finishedCandidates[0].timer;\n      if (finishedTimer) {\n        entityCache.lastDuration = finishedTimer.duration || 0;\n        entityCache.lastLabel = finishedTimer.label || 'Timer';\n      }\n    }\n\n    // Clean up finished timer cache if the finished timer is no longer in the timers array\n    if (entityCache.finishedTimerId) {\n      const finishedTimerStillExists = allTimers.some((timer: any) => \n        String(timer.timer_id) === entityCache.finishedTimerId\n      );\n      \n      if (!finishedTimerStillExists) {\n        // Timer was dismissed or removed, clear the cache immediately\n        delete entityCache.finishedTimerId;\n        delete entityCache.lastDuration;\n        delete entityCache.lastLabel;\n      }\n    }\n\n    // Find primary timer to display\n    let primaryTimer: any = null;\n    let primaryTimerId: string | null = null;\n\n    // 1. Check for ringing timers first (immediate finished state)\n    for (const timer of allTimers) {\n      if (timer.timer_id && timer.status === 'ringing') {\n        return {\n          isActive: false,\n          isPaused: false,\n          duration: timer.duration || 0,\n          remaining: 0,\n          finishesAt: null,\n          progress: 100,\n          finished: true,\n          isGoogleTimer: true,\n          userDefinedLabel: timer.label || undefined,\n          googleTimerId: String(timer.timer_id),\n          googleTimerStatus: 'ringing',\n        };\n      }\n    }\n\n    // 2. Check if we have a finished timer to display\n    if (entityCache.finishedTimerId && allTimersMap.has(entityCache.finishedTimerId)) {\n      const finishedTimer = allTimersMap.get(entityCache.finishedTimerId);\n      if (finishedTimer && finishedTimer.fire_time <= now) {\n        return {\n          isActive: false,\n          isPaused: false,\n          duration: finishedTimer.duration || 0,\n          remaining: 0,\n          finishesAt: null,\n          progress: 100,\n          finished: true,\n          isGoogleTimer: true,\n          userDefinedLabel: finishedTimer.label || undefined,\n          googleTimerId: String(finishedTimer.timer_id),\n          googleTimerStatus: finishedTimer.status || 'ringing',\n        };\n      }\n    }\n\n    // 3. Find active timer with earliest fire time\n    let earliestFireTime = Number.POSITIVE_INFINITY;\n    for (const [timerId, timer] of activeTimers.entries()) {\n      if (timer.fire_time && timer.fire_time < earliestFireTime) {\n        earliestFireTime = timer.fire_time;\n        primaryTimer = timer;\n        primaryTimerId = timerId;\n      }\n    }\n\n    // 4. If no active timers, check for paused timers\n    if (!primaryTimer) {\n      for (const timer of allTimers) {\n        if (timer.timer_id) {\n          const status = String(timer.status || '').toLowerCase().trim();\n          if (status === 'paused') {\n            primaryTimer = timer;\n            primaryTimerId = String(timer.timer_id);\n            break;\n          }\n        }\n      }\n    }\n\n    if (!primaryTimer) {\n      // If we have timers but none are active or paused, use the first one as a fallback\n      // This helps in cases where the state is not one we explicitly handle\n      if (allTimers.length > 0) {\n        primaryTimer = allTimers[0];\n        primaryTimerId = String(allTimers[0].timer_id || 'unknown');\n      } else {\n        return null; // No timers at all\n      }\n    }\n\n    // --- Calculate timer properties ---\n    const statusStr = String(primaryTimer.status || '').toLowerCase().trim();\n    const isActive = statusStr === 'set' || statusStr === 'ringing';\n    const isPaused = statusStr === 'paused';\n    const isRinging = statusStr === 'ringing';\n\n    const duration = typeof primaryTimer.duration === 'number' \n      ? primaryTimer.duration \n      : parseDuration(primaryTimer.duration || '0');\n    \n    let remaining = 0;\n    let finishesAt: Date | null = null;\n    let isFinished = false;\n\n    if (!entityCache.pausedSnapshots) {\n      entityCache.pausedSnapshots = new Map();\n    }\n    const previousSnapshot = entityCache.pausedSnapshots.get(primaryTimerId!);\n    \n    if (isActive) {\n      const fireTimeMs = primaryTimer.fire_time ? primaryTimer.fire_time * 1000 : 0;\n      \n      if (fireTimeMs && fireTimeMs > Date.now()) {\n        remaining = Math.max(0, Math.floor((fireTimeMs - Date.now()) / 1000));\n        finishesAt = new Date(fireTimeMs);\n        \n        entityCache.pausedSnapshots.set(primaryTimerId!, {\n          remaining,\n          pausedAt: now,\n          wasActive: true\n        });\n      } else {\n        remaining = 0;\n        finishesAt = null;\n        isFinished = true;\n      }\n    } else if (isPaused) {\n      // For paused timers, determine remaining time from cache or duration\n      if (previousSnapshot) {\n          remaining = previousSnapshot.remaining;\n      } else {\n          // No cached data, use duration as a fallback. This can happen if HA restarts.\n          remaining = duration;\n      }\n      \n      // Update cache to reflect current paused state\n      entityCache.pausedSnapshots.set(primaryTimerId!, {\n        remaining,\n        pausedAt: now,\n        wasActive: false\n      });\n      finishesAt = null;\n    } else {\n      // Timer is in another state (e.g., idle, or just finished)\n      remaining = 0;\n      finishesAt = null;\n      isFinished = true;\n    }\n\n    // Calculate progress\n    let progress = 0;\n    if (duration > 0) {\n      if (isRinging || isFinished || (remaining === 0 && !isPaused)) {\n        progress = 100;\n      } else {\n        const elapsed = Math.max(0, duration - remaining);\n        progress = Math.min(100, Math.max(0, (elapsed / duration) * 100));\n      }\n    }\n    \n    if (!isFinished) {\n      isFinished = isRinging || (remaining === 0 && !isPaused);\n    }\n\n    if (entityCache.pausedSnapshots && primaryTimerId && (isFinished || isActive)) {\n      if (isActive && previousSnapshot?.wasActive === false) {\n          // Timer was paused and is now active, clear snapshot\n          entityCache.pausedSnapshots.delete(primaryTimerId);\n      } else if (isFinished) {\n          // Timer finished, clear snapshot\n          entityCache.pausedSnapshots.delete(primaryTimerId);\n      }\n    }\n\n    return {\n      isActive: isActive && !isRinging,\n      isPaused,\n      duration,\n      remaining,\n      finishesAt,\n      progress,\n      finished: isFinished,\n      isGoogleTimer: true,\n      userDefinedLabel: primaryTimer.label || undefined,\n      googleTimerId: primaryTimerId || undefined,\n      googleTimerStatus: primaryTimer.status,\n    };\n  }\n\n  /**\n   * AUTO-DISCOVERY: Finds Google Home entities with timers in a displayable state.\n   * @param hass - Home Assistant object\n   * @param isGoogleTimer - Google timer detection function\n   * @returns string[] - Array of entity IDs with active, paused, or ringing timers\n   */\n  static discoverGoogleTimers(\n    hass: HomeAssistant,\n    isGoogleTimer: (entityId: string) => boolean,\n    getTimerData: (entityId: string, hass: HomeAssistant) => TimerData | null\n  ): string[] {\n    if (!hass || !hass.states) return [];\n    \n    const googleTimers: string[] = [];\n    \n    for (const entityId in hass.states) {\n      if (isGoogleTimer(entityId)) {\n        const entity = hass.states[entityId];\n        \n        // Don't skip based on entity state - Google Home entities can be \"unavailable\" \n        // but still have valid timer data in attributes\n        const attributes = entity.attributes || {};\n        const timers = attributes.timers || [];\n\n        if (Array.isArray(timers) && timers.length > 0) {\n          const hasDisplayableTimer = timers.some(timer => {\n            const status = String(timer.status || '').toLowerCase().trim();\n            return status === 'set' || status === 'ringing' || status === 'paused';\n          });\n          \n          if (hasDisplayableTimer) {\n            googleTimers.push(entityId);\n          }\n        }\n      }\n    }\n    \n    return googleTimers;\n  }\n\n  /**\n   * Manually clear finished timer cache for an entity (for user dismissal)\n   * @param entityId - Google Home timer entity ID\n   */\n  static clearFinishedTimer(entityId: string): void {\n    const entityCache = this.googleIdCache.get(entityId);\n    if (entityCache && entityCache.finishedTimerId) {\n      delete entityCache.finishedTimerId;\n      delete entityCache.lastDuration;\n      delete entityCache.lastLabel;\n    }\n  }\n}\n","import { HomeAssistant } from '../types/index';\nimport { StandardTimerService } from './StandardTimer';\nimport { AlexaTimerService } from './AlexaTimer';\nimport { GoogleTimerService } from './GoogleTimer';\n\nexport interface TimerData {\n  isActive: boolean;\n  isPaused: boolean;\n  duration: number; // in seconds\n  remaining: number; // in seconds\n  finishesAt: Date | null;\n  progress: number; // 0-100\n  finished?: boolean; // explicit finished flag (Alexa)\n  // NEW: Alexa-specific properties\n  isAlexaTimer?: boolean;\n  alexaDevice?: string;\n  timerLabel?: string;\n  // Enhanced Alexa properties\n  timerStatus?: \"ON\" | \"OFF\" | \"PAUSED\"; // Precise status from attributes\n  userDefinedLabel?: string; // User-defined timer label (e.g., \"Pizza\")\n  // NEW: Google Home specific properties\n  isGoogleTimer?: boolean;\n  googleTimerId?: string; // Google Home timer_id for tracking\n  googleTimerStatus?: \"none\" | \"set\" | \"ringing\" | \"paused\"; // Google Home timer status (includes ringing)\n}\n\n/**\n * TimerEntityService - Enhanced with Amazon Alexa & Google Home Timer support\n * Handles Home Assistant timer entity integration including Alexa Media Player and Google Home timers\n * Acts as orchestrator between StandardTimer, AlexaTimer, and GoogleTimer services\n */\nexport class TimerEntityService {\n  \n  /**\n   * Checks if an entity ID is a timer entity (including Alexa and Google timers)\n   * @param entityId - Entity ID to check\n   * @returns boolean - Whether the entity is a timer\n   */\n  static isTimerEntity(entityId: string): boolean {\n    if (!entityId) return false;\n    \n    // Standard HA timers\n    if (entityId.startsWith('timer.')) return true;\n    \n    // Alexa Media Player timer sensors\n    if (entityId.includes('_next_timer') || \n        entityId.includes('alexa_timer') || \n        (entityId.startsWith('sensor.') && entityId.includes('timer'))) {\n      return true;\n    }\n    \n    // Google Home timer sensors (ha-google-home integration)\n    // Pattern: sensor.{device_name}_timers\n    if (entityId.startsWith('sensor.') && entityId.endsWith('_timers')) {\n      return true;\n    }\n    \n    // Fallback for Google Home timers that might have different patterns\n    if (entityId.includes('google_home') && entityId.includes('timer')) {\n      return true;\n    }\n    \n    return false;\n  }\n\n  /**\n   * Checks if entity is an Alexa timer specifically\n   * @param entityId - Entity ID to check\n   * @returns boolean - Whether this is an Alexa timer\n   */\n  static isAlexaTimer(entityId: string): boolean {\n    return entityId.includes('_next_timer') || \n           entityId.includes('alexa_timer') || \n           (entityId.startsWith('sensor.') && entityId.includes('alexa') && entityId.includes('timer'));\n  }\n\n  /**\n   * Checks if entity is a Google Home timer specifically\n   * @param entityId - Entity ID to check\n   * @returns boolean - Whether this is a Google Home timer\n   */\n  static isGoogleTimer(entityId: string): boolean {\n    // Primary pattern for ha-google-home integration: sensor.{device_name}_timers\n    if (entityId.startsWith('sensor.') && entityId.endsWith('_timers')) {\n      return true;\n    }\n    \n    // Secondary patterns for Google Home timers\n    return entityId.includes('google_home') && entityId.includes('timer');\n  }\n\n  /**\n   * Gets timer data from a Home Assistant timer entity (including Alexa and Google timers)\n   * @param entityId - Timer entity ID\n   * @param hass - Home Assistant object\n   * @returns TimerData object with timer information\n   */\n  static getTimerData(entityId: string, hass: HomeAssistant): TimerData | null {\n    if (!hass || !entityId || !this.isTimerEntity(entityId)) {\n      return null;\n    }\n\n    const entity = hass.states[entityId];\n    if (!entity) {\n      return null;\n    }\n\n    // Handle Alexa timers\n    if (this.isAlexaTimer(entityId)) {\n      return AlexaTimerService.getAlexaTimerData(\n        entityId, \n        entity, \n        hass,\n        this.isISOTimestamp,\n        this.parseDuration\n      );\n    }\n\n    // Handle Google Home timers\n    if (this.isGoogleTimer(entityId)) {\n      return GoogleTimerService.getGoogleTimerData(\n        entityId,\n        entity,\n        hass,\n        this.parseDuration\n      );\n    }\n\n    // Handle standard HA timers\n    return StandardTimerService.getStandardTimerData(\n      entityId, \n      entity, \n      this.parseDuration\n    );\n  }\n  /**\n   * AUTO-DISCOVERY: Attempts to find Alexa timer entities in Home Assistant\n   * @param hass - Home Assistant object\n   * @returns string[] - Array of potential Alexa timer entity IDs\n   */\n  static discoverAlexaTimers(hass: HomeAssistant): string[] {\n    return AlexaTimerService.discoverAlexaTimers(\n      hass, \n      (entityId: string) => this.isAlexaTimer(entityId), \n      (entityId: string, hass: HomeAssistant) => this.getTimerData(entityId, hass)\n    );\n  }\n\n  /**\n   * AUTO-DISCOVERY: Attempts to find Google Home timer entities in Home Assistant\n   * @param hass - Home Assistant object\n   * @returns string[] - Array of potential Google Home timer entity IDs\n   */\n  static discoverGoogleTimers(hass: HomeAssistant): string[] {\n    return GoogleTimerService.discoverGoogleTimers(\n      hass,\n      (entityId: string) => this.isGoogleTimer(entityId),\n      (entityId: string, hass: HomeAssistant) => this.getTimerData(entityId, hass)\n    );\n  }\n\n  /**\n   * Checks if a string is an ISO timestamp\n   * @param str - String to check\n   * @returns boolean - Whether string is ISO timestamp\n   */\n  private static isISOTimestamp(str: string): boolean {\n    // Check for ISO 8601 format\n    const isoRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{3})?([+-]\\d{2}:\\d{2}|Z)?$/;\n    return isoRegex.test(str);\n  }\n\n  /**\n   * Parses duration from various formats (seconds, HH:MM:SS, etc.)\n   * @param duration - Duration value to parse\n   * @returns number - Duration in seconds\n   */\n  private static parseDuration(duration: any): number {\n    if (typeof duration === 'number') {\n      return duration;\n    }\n\n    if (typeof duration !== 'string') {\n      return 0;\n    }\n\n    // Handle HH:MM:SS format\n    if (duration.includes(':')) {\n      const parts = duration.split(':').map(Number);\n      if (parts.length === 3) {\n        // HH:MM:SS\n        return parts[0] * 3600 + parts[1] * 60 + parts[2];\n      } else if (parts.length === 2) {\n        // MM:SS\n        return parts[0] * 60 + parts[1];\n      }\n    }\n\n    // Try to parse as number (seconds)\n    const seconds = parseFloat(duration);\n    return isNaN(seconds) ? 0 : seconds;\n  }\n\n  /**\n   * Formats remaining time as human-readable string\n   * @param remaining - Remaining time in seconds\n   * @param showSeconds - Whether to include seconds in output\n   * @returns string - Formatted time string\n   */\n  static formatRemainingTime(remaining: number, showSeconds: boolean = true): string {\n    if (remaining <= 0) {\n      return '0:00';\n    }\n\n    const hours = Math.floor(remaining / 3600);\n    const minutes = Math.floor((remaining % 3600) / 60);\n    const seconds = Math.floor(remaining % 60);\n\n    if (hours > 0) {\n      if (showSeconds) {\n        return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n      } else {\n        return `${hours}:${minutes.toString().padStart(2, '0')}`;\n      }\n    } else {\n      if (showSeconds) {\n        return `${minutes}:${seconds.toString().padStart(2, '0')}`;\n      } else {\n        return `${minutes}m`;\n      }\n    }\n  }\n\n  /**\n   * Gets appropriate title text for timer entity (enhanced for Alexa and Google Home)\n   * @param entityId - Timer entity ID\n   * @param hass - Home Assistant object\n   * @param customTitle - Custom title override\n   * @returns string - Title text\n   */\n  static getTimerTitle(entityId: string, hass: HomeAssistant, customTitle?: string): string {\n    if (customTitle) {\n      return customTitle;\n    }\n\n    if (!hass || !entityId) {\n      return 'Timer';\n    }\n\n    const entity = hass.states[entityId];\n    if (!entity) {\n      return 'Timer';\n    }\n\n    // Handle Alexa timers\n    if (this.isAlexaTimer(entityId)) {\n      const timerData = AlexaTimerService.getAlexaTimerData(\n        entityId, \n        entity, \n        hass,\n        this.isISOTimestamp,\n        this.parseDuration\n      );\n      if (timerData?.timerLabel) {\n        return timerData.timerLabel;\n      }\n      return this.formatAlexaTimerName(entityId);\n    }\n\n    // Handle Google Home timers\n    if (this.isGoogleTimer(entityId)) {\n      const timerData = GoogleTimerService.getGoogleTimerData(\n        entityId,\n        entity,\n        hass,\n        this.parseDuration\n      );\n      if (timerData?.userDefinedLabel) {\n        return timerData.userDefinedLabel;\n      }\n      return this.formatGoogleTimerName(entityId);\n    }\n\n    // Use friendly name or fall back to entity ID\n    return entity.attributes.friendly_name || entityId.replace('timer.', '').replace(/_/g, ' ');\n  }\n\n  /**\n   * Formats Alexa timer name from entity ID\n   * @param entityId - Entity ID\n   * @returns string - Formatted name\n   */\n  private static formatAlexaTimerName(entityId: string): string {\n    return entityId\n      .replace(/^sensor\\./, '')\n      .replace(/_next_timer$/, '')\n      .replace(/_timer$/, '')\n      .replace(/_/g, ' ')\n      .replace(/\\b\\w/g, l => l.toUpperCase());\n  }\n\n  /**\n   * Formats Google Home timer name from entity ID\n   * @param entityId - Entity ID\n   * @returns string - Formatted name\n   */\n  private static formatGoogleTimerName(entityId: string): string {\n    return entityId\n      .replace(/^sensor\\./, '')\n      .replace(/_timers$/, '')\n      .replace(/_/g, ' ')\n      .replace(/\\b\\w/g, l => l.toUpperCase()) + ' Timers';\n  }\n\n  /**\n   * Checks if a timer is expired\n   * @param timerData - Timer data object\n   * @returns boolean - Whether the timer is expired\n   */\n  static isTimerExpired(timerData: TimerData): boolean {\n    if (!timerData) return false;\n    \n    if (timerData.isAlexaTimer) {\n      return !!timerData.finished || (timerData.remaining === 0 && timerData.progress >= 100);\n    }\n    \n    if (timerData.isGoogleTimer) {\n      return !!timerData.finished || (timerData.remaining === 0 && timerData.progress >= 100);\n    }\n    \n    // Standard HA timer\n    return !timerData.isActive && !timerData.isPaused && timerData.progress >= 100;\n  }\n\n  /**\n   * Gets subtitle text for timer display\n   * @param timerData - Timer data object\n   * @param showSeconds - Whether to show seconds in display\n   * @returns string - Subtitle text\n   */\n  static getTimerSubtitle(timerData: TimerData, showSeconds: boolean = true): string {\n    if (!timerData) {\n      return 'Timer not found';\n    }\n\n    if (timerData.isAlexaTimer) {\n      if (timerData.finished) {\n        return timerData.userDefinedLabel \n          ? `${timerData.userDefinedLabel} timer complete`\n          : 'Timer complete';\n      }\n\n      if (timerData.isActive && timerData.remaining > 0) {\n        const remaining = this.formatRemainingTime(timerData.remaining, showSeconds);\n        return timerData.userDefinedLabel\n          ? `${remaining} remaining on ${timerData.userDefinedLabel} timer`\n          : timerData.alexaDevice\n          ? `${remaining} remaining on ${timerData.alexaDevice}`\n          : `${remaining} remaining`;\n      }\n\n      if (timerData.isPaused && timerData.remaining > 0) {\n        const remaining = this.formatRemainingTime(timerData.remaining, showSeconds);\n        return timerData.userDefinedLabel\n          ? `${timerData.userDefinedLabel} timer paused - ${remaining} left`\n          : timerData.alexaDevice\n          ? `Timer paused on ${timerData.alexaDevice} - ${remaining} left`\n          : `Timer paused - ${remaining} left`;\n      }\n\n      if (timerData.finished || (timerData.remaining === 0 && timerData.progress >= 100)) {\n        return timerData.userDefinedLabel\n          ? `${timerData.userDefinedLabel} timer complete`\n          : 'Timer complete';\n      }\n\n      return timerData.alexaDevice \n        ? `No timers on ${timerData.alexaDevice}`\n        : 'No timers';\n    }\n\n    if (timerData.isGoogleTimer) {\n      const isRinging = timerData.googleTimerStatus === 'ringing';\n      \n      if (timerData.finished || isRinging) {\n        return timerData.userDefinedLabel \n          ? `${timerData.userDefinedLabel} timer complete`\n          : 'Timer complete';\n      }\n\n      if (timerData.isActive && timerData.remaining > 0) {\n        const remaining = this.formatRemainingTime(timerData.remaining, showSeconds);\n        return timerData.userDefinedLabel\n          ? `${remaining} remaining on ${timerData.userDefinedLabel} timer`\n          : `${remaining} remaining on Google Home`;\n      }\n\n      if (timerData.isPaused && timerData.remaining > 0) {\n        const remaining = this.formatRemainingTime(timerData.remaining, showSeconds);\n        return timerData.userDefinedLabel\n          ? `${timerData.userDefinedLabel} timer paused - ${remaining} left`\n          : `Google Home timer paused - ${remaining} left`;\n      }\n\n      if (timerData.finished || isRinging || \n          (timerData.remaining === 0 && timerData.progress >= 100)) {\n        return timerData.userDefinedLabel\n          ? `${timerData.userDefinedLabel} timer complete`\n          : 'Timer complete';\n      }\n\n      return 'No Google Home timers';\n    }\n\n    // Standard HA timer\n    if (timerData.isActive) {\n      return `${this.formatRemainingTime(timerData.remaining, showSeconds)} remaining`;\n    }\n\n    if (timerData.isPaused) {\n      return `Paused - ${this.formatRemainingTime(timerData.remaining, showSeconds)} left`;\n    }\n\n    if (timerData.duration > 0) {\n      return `Ready - ${this.formatRemainingTime(timerData.duration, showSeconds)}`;\n    }\n\n    return 'Timer ready';\n  }\n\n  /**\n   * Gets timer state color based on status\n   * @param timerData - Timer data object\n   * @param defaultColor - Default color if no specific state\n   * @returns string - Color hex value\n   */\n  static getTimerStateColor(timerData: TimerData, defaultColor: string = '#4caf50'): string {\n    if (!timerData) return defaultColor;\n    \n    if (timerData.isAlexaTimer) {\n      if (timerData.isActive && timerData.remaining > 0) {\n        return '#00d4ff'; // Alexa blue\n      }\n      \n      if (this.isTimerExpired(timerData)) {\n        return '#ff4444'; // Red for expired\n      }\n      \n      return '#888888'; // Gray for inactive\n    }\n\n    if (timerData.isGoogleTimer) {\n      if (timerData.isActive && timerData.remaining > 0) {\n        return '#34a853'; // Google green\n      }\n      \n      if (this.isTimerExpired(timerData)) {\n        return '#ff4444'; // Red for expired\n      }\n      \n      return '#888888'; // Gray for inactive\n    }\n    \n    // Standard HA timer colors\n    if (timerData.isActive) {\n      return '#4caf50'; // Green for active\n    }\n    \n    if (timerData.isPaused) {\n      return '#ff9800'; // Orange for paused\n    }\n    \n    if (this.isTimerExpired(timerData)) {\n      return '#f44336'; // Red for expired\n    }\n    \n    return '#9e9e9e'; // Gray for idle\n  }\n}","/**\n * DateParser - Enhanced date parsing utility with a more streamlined fallback system\n * Handles cross-browser compatibility and edge cases for date string parsing\n */\nexport class DateParser {\n  /**\n   * Main entry point for date parsing with a hybrid approach\n   * @param {string} dateString - ISO date string to parse\n   * @returns {number} - Unix timestamp in milliseconds\n   */\n  static parseISODate(dateString: string): number {\n    // First, try a robust manual parsing for common ISO formats.\n    // This is more consistent across browsers than new Date().\n    try {\n      const manualResult = this.parseISODateManual(dateString);\n      if (!isNaN(manualResult)) {\n        return manualResult;\n      }\n    } catch (e) {\n      // Fall through to other methods if manual parsing fails\n    }\n\n    // Second, try the native Date constructor, which can handle more formats.\n    const nativeResult = new Date(dateString);\n    if (!isNaN(nativeResult.getTime()) && this.isValidDateResult(nativeResult, dateString)) {\n      return nativeResult.getTime();\n    }\n    \n    // If all else fails, use the final fallback.\n    return this.parseISODateFallback(dateString);\n  }\n\n  /**\n   * Validates that a parsed date result is reasonable\n   * @param {Date} dateObj - Parsed date object\n   * @param {string} originalString - Original date string\n   * @returns {boolean} - Whether the date is valid\n   */\n  static isValidDateResult(dateObj: Date, originalString: string): boolean {\n    const timestamp = dateObj.getTime();\n    \n    // Check for reasonable date range (1970-2100)\n    const minTimestamp = new Date('1970-01-01').getTime();\n    const maxTimestamp = new Date('2100-12-31').getTime();\n    \n    if (timestamp < minTimestamp || timestamp > maxTimestamp) {\n      return false;\n    }\n    \n    // Check for February 29th in non-leap years\n    if (typeof originalString === 'string' && originalString.includes('02-29')) {\n      const year = dateObj.getFullYear();\n      if (!this.isLeapYear(year)) {\n        return false;\n      }\n    }\n    \n    return true;\n  }\n\n  /**\n   * Check if a year is a leap year\n   * @param {number} year - Year to check\n   * @returns {boolean} - Whether the year is a leap year\n   */\n  static isLeapYear(year: number): boolean {\n    return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n  }\n\n  /**\n   * Enhanced manual parsing with better error handling\n   * @param {string} dateString - Date string to parse\n   * @returns {number} - Unix timestamp\n   */\n  static parseISODateManual(dateString: string): number {\n    if (typeof dateString === 'string' && dateString.includes('T')) {\n      // Check if the string contains timezone information (Z, +XX:XX, -XX:XX)\n      const hasTimezone = /[+-]\\d{2}:\\d{2}$|Z$/.test(dateString);\n      \n      if (hasTimezone) {\n        // For ISO strings with timezone info, use native Date parsing to preserve timezone\n        return new Date(dateString).getTime();\n      } else {\n        // For timezone-less ISO strings, use manual parsing for cross-platform consistency\n        const [datePart, timePart] = dateString.split('T');\n        const [year, month, day] = datePart.split('-').map(Number);\n        \n        // Validate date components\n        if (!this.isValidDateComponents(year, month, day)) {\n          throw new Error('Invalid date components');\n        }\n        \n        if (timePart && timePart.includes(':')) {\n          const [hour, minute, second] = timePart.split(':').map(parseFloat);\n          \n          // Validate time components\n          if (!this.isValidTimeComponents(hour, minute, second)) {\n            throw new Error('Invalid time components');\n          }\n          \n          return new Date(year, month - 1, day, hour, minute, second || 0).getTime();\n        } else {\n          return new Date(year, month - 1, day).getTime();\n        }\n      }\n    } else {\n      // Fallback to regular parsing for other formats\n      return new Date(dateString).getTime();\n    }\n  }\n\n  /**\n   * Validates date components\n   * @param {number} year - Year component\n   * @param {number} month - Month component (1-12)\n   * @param {number} day - Day component\n   * @returns {boolean} - Whether components are valid\n   */\n  static isValidDateComponents(year: number, month: number, day: number): boolean {\n    if (isNaN(year) || isNaN(month) || isNaN(day)) return false;\n    if (year < 1970 || year > 2100) return false;\n    if (month < 1 || month > 12) return false;\n    if (day < 1 || day > 31) return false;\n    \n    // Check days in month\n    const daysInMonth = [31, this.isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if (day > daysInMonth[month - 1]) return false;\n    \n    return true;\n  }\n\n  /**\n   * Validates time components\n   * @param {number} hour - Hour component\n   * @param {number} minute - Minute component\n   * @param {number} second - Second component\n   * @returns {boolean} - Whether components are valid\n   */\n  static isValidTimeComponents(hour: any, minute: any, second: any): boolean {\n    const h = parseInt(hour);\n    const m = parseInt(minute);\n    const s = parseInt(second);\n    \n    if (isNaN(h) || isNaN(m) || isNaN(s)) return false;\n    if (h < 0 || h > 23) return false;\n    if (m < 0 || m > 59) return false;\n    if (s < 0 || s > 59) return false;\n    \n    return true;\n  }\n\n  /**\n   * Final fallback parsing method\n   * @param {string} dateString - Date string to parse\n   * @returns {number} - Unix timestamp\n   */\n  static parseISODateFallback(dateString: string): number {\n    try {\n      const timestamp = Date.parse(dateString);\n      if (!isNaN(timestamp)) {\n        return timestamp;\n      }\n      \n      // Last resort: return current time as fallback\n      return Date.now();\n    } catch (error) {\n      return Date.now();\n    }\n  }\n}","/**\n * ConfigValidator - Comprehensive input validation for TimeFlow Card configuration\n * Ensures security, type safety, and data integrity with graceful error handling\n */\n\nexport interface ValidationError {\n  field: string;\n  message: string;\n  severity: 'critical' | 'warning' | 'info';\n  suggestion?: string;\n  value?: any;\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  errors: ValidationError[];\n  hasCriticalErrors: boolean;\n  hasWarnings: boolean;\n  safeConfig?: any;\n}\n\nexport class ConfigValidator {\n  /**\n   * Comprehensive input validation for configuration with severity levels\n   * @param {Object} config - Configuration object to validate\n   * @returns {ValidationResult} - Detailed validation result\n   */\n  static validateConfig(config: any): ValidationResult {\n    const errors: ValidationError[] = [];\n    \n    // Check if config is null or undefined\n    if (!config) {\n      errors.push({\n        field: 'config',\n        message: 'Configuration object is missing or empty',\n        severity: 'critical',\n        suggestion: 'Provide a valid configuration object with at least a target_date field.',\n        value: config\n      });\n      return {\n        isValid: false,\n        errors,\n        hasCriticalErrors: true,\n        hasWarnings: false\n      };\n    }\n    \n    // Validate target_date (required field, unless using timer_entity or auto_discover_alexa)\n    if (config.target_date) {\n      if (!this.isValidDateInput(config.target_date)) {\n        errors.push({\n          field: 'target_date',\n          message: 'Invalid target_date format',\n          severity: 'critical',\n          suggestion: 'Use ISO date string (2025-12-31T23:59:59), entity ID (sensor.my_date), or template ({{ states(\"sensor.date\") }}).',\n          value: config.target_date\n        });\n      }\n    } else if (!config.timer_entity && !config.auto_discover_alexa) {\n      // target_date is only required if timer_entity and auto_discover_alexa are not provided\n      errors.push({\n        field: 'target_date',\n        message: 'Either \"target_date\", \"timer_entity\", or \"auto_discover_alexa\" must be provided',\n        severity: 'critical',\n        suggestion: 'Add target_date field with a valid date value like \"2025-12-31T23:59:59\" OR specify a timer_entity like \"timer.my_timer\" OR enable auto_discover_alexa.',\n        value: undefined\n      });\n    }\n    \n    // Validate timer_entity if provided\n    if (config.timer_entity && !this.isValidEntityId(config.timer_entity)) {\n      errors.push({\n        field: 'timer_entity',\n        message: 'Invalid timer_entity format',\n        severity: 'warning',\n        suggestion: 'Use a valid entity ID like \"timer.my_timer\" or \"sensor.alexa_timer\".',\n        value: config.timer_entity\n      });\n    }\n    \n    // Validate creation_date if provided (optional field)\n    if (config.creation_date && !this.isValidDateInput(config.creation_date)) {\n      errors.push({\n        field: 'creation_date',\n        message: 'Invalid creation_date format',\n        severity: 'warning',\n        suggestion: 'Use ISO date string, entity ID, or template. This field is optional.',\n        value: config.creation_date\n      });\n    }\n    \n    // Validate colors\n    const colorFields = ['text_color', 'background_color', 'progress_color'];\n    colorFields.forEach(field => {\n      if (config[field] && !this.isValidColorInput(config[field])) {\n        errors.push({\n          field,\n          message: `Invalid ${field} format`,\n          severity: 'warning',\n          suggestion: 'Use hex (#ff0000), rgb/rgba, hsl/hsla, CSS color name, entity ID, or template.',\n          value: config[field]\n        });\n      }\n    });\n    \n    // Validate dimensions\n    const dimensionFields = ['width', 'height', 'icon_size'];\n    dimensionFields.forEach(field => {\n      if (config[field] && !this.isValidDimensionInput(config[field])) {\n        errors.push({\n          field,\n          message: `Invalid ${field} format`,\n          severity: 'warning',\n          suggestion: 'Use pixel values (100px), percentages (50%), or CSS units (2rem).',\n          value: config[field]\n        });\n      }\n    });\n    \n    // Validate aspect_ratio\n    if (config.aspect_ratio && !this.isValidAspectRatioInput(config.aspect_ratio)) {\n      errors.push({\n        field: 'aspect_ratio',\n        message: 'Invalid aspect_ratio format',\n        severity: 'warning',\n        suggestion: 'Use format like \"16/9\", \"4/3\", or \"1/1\".',\n        value: config.aspect_ratio\n      });\n    }\n    \n    // Validate stroke_width\n    if (config.stroke_width !== undefined && !this.isValidNumberInput(config.stroke_width, 1, 50)) {\n      errors.push({\n        field: 'stroke_width',\n        message: 'Invalid stroke_width value',\n        severity: 'warning',\n        suggestion: 'Must be a number between 1 and 50.',\n        value: config.stroke_width\n      });\n    }\n    \n    // Validate boolean fields\n    const booleanFields = ['show_months', 'show_days', 'show_hours', 'show_minutes', 'show_seconds', 'expired_animation', 'show_progress_text'];\n    booleanFields.forEach(field => {\n      if (config[field] !== undefined && !this.isValidBooleanInput(config[field])) {\n        errors.push({\n          field,\n          message: `Invalid ${field} value`,\n          severity: 'warning',\n          suggestion: 'Must be true or false (boolean value).',\n          value: config[field]\n        });\n      }\n    });\n    \n    // Validate text fields for XSS prevention\n    const textFields = ['title', 'subtitle', 'expired_text'];\n    textFields.forEach(field => {\n      if (config[field] && !this.isValidTextInput(config[field])) {\n        errors.push({\n          field,\n          message: `Invalid ${field} - contains potentially unsafe content`,\n          severity: 'critical',\n          suggestion: 'Remove script tags, javascript: URLs, and event handlers for security.',\n          value: config[field]\n        });\n      }\n    });\n    \n    // Validate styles object\n    if (config.styles && !this.isValidStylesInput(config.styles)) {\n      errors.push({\n        field: 'styles',\n        message: 'Invalid styles object structure',\n        severity: 'warning',\n        suggestion: 'Must contain valid style arrays for card, title, subtitle, or progress_circle.',\n        value: config.styles\n      });\n    }\n\n    // Additional helpful validations\n    this._addHelpfulValidations(config, errors);\n\n    // Generate safe config for graceful degradation\n    const safeConfig = this._generateSafeConfig(config, errors);\n\n    const criticalErrors = errors.filter(e => e.severity === 'critical');\n    const warnings = errors.filter(e => e.severity === 'warning');\n\n    return {\n      isValid: criticalErrors.length === 0 && warnings.length === 0,\n      errors,\n      hasCriticalErrors: criticalErrors.length > 0,\n      hasWarnings: warnings.length > 0,\n      safeConfig\n    };\n  }\n\n  /**\n   * Add additional helpful validations and suggestions\n   */\n  private static _addHelpfulValidations(config: any, errors: ValidationError[]): void {\n    // No additional validations needed - only validate fields that exist in config\n    // Remove unknown field warnings as requested\n  }\n\n  /**\n   * Generate a safe configuration with fallback values\n   */\n  private static _generateSafeConfig(config: any, errors: ValidationError[]): any {\n    const safeConfig = { ...config };\n    \n    // Apply safe defaults for fields with errors\n    errors.forEach(error => {\n      if (error.severity === 'critical' || error.severity === 'warning') {\n        switch (error.field) {\n          case 'target_date':\n            if (!safeConfig.target_date && !safeConfig.timer_entity) {\n              // Only set a default target_date if no timer_entity is provided\n              const tomorrow = new Date();\n              tomorrow.setDate(tomorrow.getDate() + 1);\n              safeConfig.target_date = tomorrow.toISOString();\n            }\n            break;\n          case 'background_color':\n            if (!this.isValidColorInput(safeConfig.background_color)) {\n              safeConfig.background_color = '#1a1a1a';\n            }\n            break;\n          case 'progress_color':\n            if (!this.isValidColorInput(safeConfig.progress_color)) {\n              safeConfig.progress_color = '#4caf50';\n            }\n            break;\n          case 'stroke_width':\n            if (!this.isValidNumberInput(safeConfig.stroke_width, 1, 50)) {\n              safeConfig.stroke_width = 15;\n            }\n            break;\n          case 'icon_size':\n            if (!this.isValidDimensionInput(safeConfig.icon_size)) {\n              safeConfig.icon_size = 100;\n            }\n            break;\n        }\n      }\n    });\n\n    return safeConfig;\n  }\n\n  /**\n   * Legacy method for backward compatibility - now throws ValidationError\n   * @deprecated Use validateConfig() instead which returns ValidationResult\n   */\n  static validateConfigLegacy(config: any): void {\n    const result = this.validateConfig(config);\n    if (result.hasCriticalErrors) {\n      const criticalErrors = result.errors.filter(e => e.severity === 'critical');\n      throw new Error(`Configuration validation failed:\\n ${criticalErrors.map(e => e.message).join('\\n ')}`);\n    }\n  }\n  \n  /**\n   * Validates date input (string, entity, or template)\n   * @param {*} value - Value to validate\n   * @returns {boolean} - Whether the value is valid\n   */\n  static isValidDateInput(value: any): boolean {\n    if (!value) return false;\n    \n    // Allow templates\n    if (this.isTemplate(value)) return true;\n    \n    // Allow entity IDs\n    if (typeof value === 'string' && value.includes('.')) return true;\n    \n    // Validate date string format\n    if (typeof value === 'string') {\n      try {\n        const date = new Date(value);\n        return !isNaN(date.getTime());\n      } catch (e) {\n        return false;\n      }\n    }\n    \n    return false;\n  }\n  \n  /**\n   * Validates color input (color value, entity, or template)\n   * @param {*} value - Value to validate\n   * @returns {boolean} - Whether the value is valid\n   */\n  static isValidColorInput(value: any): boolean {\n    if (!value) return false;\n    \n    // Allow templates and entities\n    if (this.isTemplate(value) || (typeof value === 'string' && value.includes('.'))) return true;\n    \n    if (typeof value !== 'string') return false;\n    \n    // Check hex colors\n    if (/^#([0-9A-F]{3}){1,2}$/i.test(value)) return true;\n    \n    // Check rgb/rgba\n    if (/^rgba?\\(\\s*\\d+\\s*,\\s*\\d+\\s*,\\s*\\d+\\s*(,\\s*[\\d.]+\\s*)?\\)$/i.test(value)) return true;\n    \n    // Check hsl/hsla\n    if (/^hsla?\\(\\s*\\d+\\s*,\\s*\\d+%\\s*,\\s*\\d+%\\s*(,\\s*[\\d.]+\\s*)?\\)$/i.test(value)) return true;\n    \n    // Check CSS color names (expanded list)\n    const cssColors = [\n      'red', 'blue', 'green', 'yellow', 'orange', 'purple', 'pink', 'brown', 'black', 'white', 'gray', 'grey',\n      'cyan', 'magenta', 'lime', 'maroon', 'navy', 'olive', 'teal', 'silver', 'gold', 'indigo', 'violet',\n      'transparent', 'currentColor', 'inherit', 'initial', 'unset'\n    ];\n    \n    return cssColors.includes(value.toLowerCase());\n  }\n  \n  /**\n   * Validates dimension input (dimension value, entity, or template)\n   * @param {*} value - Value to validate\n   * @returns {boolean} - Whether the value is valid\n   */\n  static isValidDimensionInput(value: any): boolean {\n    if (!value) return false;\n    \n    // Allow templates and entities\n    if (this.isTemplate(value) || (typeof value === 'string' && value.includes('.'))) return true;\n    \n    // Allow numbers\n    if (typeof value === 'number') return true;\n    \n    if (typeof value !== 'string') return false;\n    \n    // Check pixel values (0-10000px)\n    const pxMatch = value.match(/^(\\d+(?:\\.\\d+)?)px$/i);\n    if (pxMatch) {\n      const px = parseFloat(pxMatch[1]);\n      return px >= 0 && px <= 10000;\n    }\n    \n    // Check percentage values (0-1000%)\n    const percentMatch = value.match(/^(\\d+(?:\\.\\d+)?)%$/i);\n    if (percentMatch) {\n      const percent = parseFloat(percentMatch[1]);\n      return percent >= 0 && percent <= 1000;\n    }\n    \n    // Check other valid CSS units\n    const validUnits = ['em', 'rem', 'vh', 'vw', 'vmin', 'vmax', 'ch', 'ex'];\n    for (const unit of validUnits) {\n      const regex = new RegExp(`^(\\\\d+(?:\\\\.\\\\d+)?)${unit}$`, 'i');\n      const match = value.match(regex);\n      if (match) {\n        const unitValue = parseFloat(match[1]);\n        return unitValue >= 0 && unitValue <= 1000; // Reasonable bounds\n      }\n    }\n    \n    // Check for 'auto', 'fit-content', etc.\n    const validKeywords = ['auto', 'fit-content', 'min-content', 'max-content'];\n    return validKeywords.includes(value.toLowerCase());\n  }\n  \n  /**\n   * Validates aspect ratio input\n   * @param {*} value - Value to validate\n   * @returns {boolean} - Whether the value is valid\n   */\n  static isValidAspectRatioInput(value: any): boolean {\n    if (!value) return false;\n    \n    // Allow templates and entities\n    if (this.isTemplate(value) || (typeof value === 'string' && value.includes('.'))) return true;\n    \n    if (typeof value !== 'string') return false;\n    \n    // Check aspect ratio format: number/number\n    const aspectMatch = value.match(/^(\\d+(?:\\.\\d+)?)\\/(\\d+(?:\\.\\d+)?)$/);\n    if (aspectMatch) {\n      const width = parseFloat(aspectMatch[1]);\n      const height = parseFloat(aspectMatch[2]);\n      return width > 0 && height > 0 && width <= 20 && height <= 20; // Reasonable bounds\n    }\n    \n    return false;\n  }\n  \n  /**\n   * Validates number input with optional bounds\n   * @param {*} value - Value to validate\n   * @param {number} min - Minimum allowed value\n   * @param {number} max - Maximum allowed value\n   * @returns {boolean} - Whether the value is valid\n   */\n  static isValidNumberInput(value: any, min: number = -Infinity, max: number = Infinity): boolean {\n    if (value === undefined || value === null) return false;\n    \n    // Allow templates and entities\n    if (typeof value === 'string') {\n      if (this.isTemplate(value) || value.includes('.')) return true;\n      // Try to parse string numbers\n      const parsed = parseFloat(value);\n      return !isNaN(parsed) && parsed >= min && parsed <= max;\n    }\n    \n    return typeof value === 'number' && !isNaN(value) && value >= min && value <= max;\n  }\n  \n  /**\n   * Validates boolean input\n   * @param {*} value - Value to validate\n   * @returns {boolean} - Whether the value is valid\n   */\n  static isValidBooleanInput(value: any): boolean {\n    return typeof value === 'boolean';\n  }\n  \n  /**\n   * Validates text input for XSS prevention\n   * @param {*} value - Value to validate\n   * @returns {boolean} - Whether the value is valid\n   */\n  static isValidTextInput(value: any): boolean {\n    if (!value) return true;\n    \n    // Allow templates and entities\n    if (this.isTemplate(value) || (typeof value === 'string' && value.includes('.'))) return true;\n    \n    if (typeof value !== 'string') return false;\n    \n    // Check for potentially dangerous content\n    const dangerousPatterns = [\n      /<script/i,\n      /javascript:/i,\n      /vbscript:/i,\n      /on\\w+\\s*=/i, // Event handlers like onclick=\n      /<iframe/i,\n      /<object/i,\n      /<embed/i,\n      /<form/i\n    ];\n    \n    return !dangerousPatterns.some(pattern => pattern.test(value));\n  }\n  \n  /**\n   * Validates styles object structure\n   * @param {*} styles - Styles object to validate\n   * @returns {boolean} - Whether the styles are valid\n   */\n  static isValidStylesInput(styles: any): boolean {\n    if (!styles || typeof styles !== 'object') return false;\n    \n    const validStyleKeys = ['card', 'title', 'subtitle', 'progress_circle'];\n    \n    // Check that all keys are valid\n    const styleKeys = Object.keys(styles);\n    if (!styleKeys.every(key => validStyleKeys.includes(key))) return false;\n    \n    // Check that all values are arrays\n    return styleKeys.every(key => Array.isArray(styles[key]));\n  }\n\n  /**\n   * Detects if a value contains Home Assistant templates\n   * @param {*} value - Value to check\n   * @returns {boolean} - Whether the value is a template\n   */\n  static isTemplate(value: any): boolean {\n    return typeof value === 'string' && \n           value.includes('{{') && \n           value.includes('}}');\n  }\n\n  /**\n   * Validates entity ID format\n   * @param {*} value - Value to validate\n   * @returns {boolean} - Whether the value is a valid entity ID\n   */\n  static isValidEntityId(value: any): boolean {\n    if (!value || typeof value !== 'string') return false;\n    \n    // Allow templates\n    if (this.isTemplate(value)) return true;\n    \n    // Basic entity ID format: domain.entity_name\n    const entityPattern = /^[a-z_]+\\.[a-z0-9_]+$/;\n    return entityPattern.test(value);\n  }\n}\n","import { HomeAssistant, TimeFlowCard } from '../types/index';\n\ninterface CacheEntry {\n  result: any;\n  timestamp: number;\n}\n\n/**\n * TemplateService - Handles Home Assistant template evaluation and caching\n * Provides efficient template processing with intelligent caching\n */\nexport class TemplateService {\n  private templateResults: Map<string, CacheEntry>;\n  private templateCacheLimit: number;\n  public card?: TimeFlowCard;\n\n  constructor() {\n    this.templateResults = new Map();\n    this.templateCacheLimit = 100;\n  }\n\n  /**\n   * Evaluates a Home Assistant template using the correct API\n   * @param {string} template - Template string to evaluate\n   * @param {Object} hass - Home Assistant object\n   * @returns {Promise<*>} - Evaluated template result\n   */\n  async evaluateTemplate(template: string, hass: HomeAssistant | null): Promise<any> {\n    if (!hass || !template) {\n      return template;\n    }\n\n    // Check cache first\n    const cacheKey = template;\n    if (this.templateResults.has(cacheKey)) {\n      const cached = this.templateResults.get(cacheKey);\n      // Check if cache is still valid (within 5 seconds)\n      if (cached && Date.now() - cached.timestamp < 5000) {\n        return cached.result;\n      }\n    }\n\n    try {\n      // Validate template format before making API call\n      if (!this.isValidTemplate(template)) {\n        throw new Error('Invalid template format');\n      }\n\n      // Use callApi method like card-tools and button-card for HA templates\n      const result = await hass.callApi('POST', 'template', { \n        template: template \n      });\n      \n      // Check if the template evaluation succeeded but returned 'unknown'\n      if (result === 'unknown' || result === 'unavailable' || result === '' || result === null) {\n        // Try to extract fallback from the template itself\n        const fallback = this.extractFallbackFromTemplate(template);\n        if (fallback && fallback !== template) {\n          // Cache the fallback result\n          this.templateResults.set(cacheKey, {\n            result: fallback,\n            timestamp: Date.now()\n          });\n          \n          // Enforce cache size limits\n          this.enforceTemplateCacheLimit();\n          \n          return fallback;\n        }\n      }\n      \n      // Cache the result\n      this.templateResults.set(cacheKey, {\n        result: result,\n        timestamp: Date.now()\n      });\n      \n      // Enforce cache size limits\n      this.enforceTemplateCacheLimit();\n      \n      return result;\n    } catch (error: any) {\n      // Template evaluation failed, use fallback\n      const fallback = this.extractFallbackFromTemplate(template);\n      \n      // Cache the fallback to prevent repeated failed calls\n      this.templateResults.set(cacheKey, {\n        result: fallback,\n        timestamp: Date.now()\n      });\n      \n      this.enforceTemplateCacheLimit();\n      return fallback;\n    }\n  }\n\n  /**\n   * Extracts fallback value from template expressions with 'or' operator\n   * @param {string} template - Template string\n   * @returns {string} - Extracted fallback value\n   */\n  extractFallbackFromTemplate(template: string): string {\n    if (!template || typeof template !== 'string') {\n      return template;\n    }\n\n    try {\n      // Remove the outer {{ }} to work with the inner expression\n      const innerTemplate = template.replace(/^\\{\\{\\s*/, '').replace(/\\s*\\}\\}$/, '').trim();\n      \n      // Look for patterns like \"states('entity') or 'fallback'\"\n      const simpleOrPattern = /^(.+?)\\s+or\\s+['\"`]([^'\"`]+)['\"`]$/;\n      const simpleOrMatch = innerTemplate.match(simpleOrPattern);\n      \n      if (simpleOrMatch && simpleOrMatch[2]) {\n        return simpleOrMatch[2];\n      }\n\n      // Look for chained or patterns like \"states('entity1') or states('entity2') or 'fallback'\"\n      const chainedOrPattern = /^(.+?)\\s+or\\s+(.+?)\\s+or\\s+['\"`]([^'\"`]+)['\"`]$/;\n      const chainedMatch = innerTemplate.match(chainedOrPattern);\n      \n      if (chainedMatch && chainedMatch[3]) {\n        return chainedMatch[3];\n      }\n\n      // Look for conditional patterns like \"'value' if condition else 'fallback'\"\n      const conditionalPattern = /^['\"`]([^'\"`]+)['\"`]\\s+if\\s+(.+?)\\s+else\\s+['\"`]([^'\"`]+)['\"`]$/;\n      const conditionalMatch = innerTemplate.match(conditionalPattern);\n      \n      if (conditionalMatch && conditionalMatch[3]) {\n        return conditionalMatch[3];\n      }\n\n      // Look for reverse conditional patterns like \"condition if test else 'fallback'\"\n      const reverseConditionalPattern = /^(.+?)\\s+if\\s+(.+?)\\s+else\\s+['\"`]([^'\"`]+)['\"`]$/;\n      const reverseMatch = innerTemplate.match(reverseConditionalPattern);\n      \n      if (reverseMatch && reverseMatch[3]) {\n        return reverseMatch[3];\n      }\n\n      // If no fallback pattern found, return a helpful message\n      return 'Unavailable';\n    } catch (error) {\n      return 'Template Error';\n    }\n  }\n\n  /**\n   * Detects if a value contains Home Assistant templates\n   * @param {*} value - Value to check\n   * @returns {boolean} - Whether the value is a template\n   */\n  isTemplate(value: any): boolean {\n    return typeof value === 'string' && \n           value.includes('{{') && \n           value.includes('}}');\n  }\n\n  /**\n   * Validates template format to prevent bad API calls\n   * @param {string} template - Template string to validate\n   * @returns {boolean} - Whether template is valid\n   */\n  isValidTemplate(template: string): boolean {\n    if (!template || typeof template !== 'string') return false;\n    \n    // Check for basic template format\n    if (!template.includes('{{') || !template.includes('}}')) return false;\n    \n    // Check for balanced braces\n    const openBraces = (template.match(/\\{\\{/g) || []).length;\n    const closeBraces = (template.match(/\\}\\}/g) || []).length;\n    if (openBraces !== closeBraces) return false;\n    \n    // Check for empty template\n    const content = template.replace(/\\{\\{\\s*/, '').replace(/\\s*\\}\\}/, '').trim();\n    if (!content) return false;\n    \n    return true;\n  }\n\n  /**\n   * Enhanced value resolver that handles entities, templates, and plain strings\n   * @param {*} value - Value to resolve\n   * @returns {Promise<*>} - Resolved value\n   */\n  async resolveValue(value: string): Promise<string | undefined> {\n    if (!value) return undefined;\n\n    if (this.isTemplate(value)) {\n      const hass = this.card?.hass || null;\n      const result = await this.evaluateTemplate(value, hass);\n      return result || undefined;\n    }\n\n    // Handle entity state\n    const hass = this.card?.hass;\n    if (typeof value === 'string' && value.includes('.') && hass && hass.states[value]) {\n      const entity = hass.states[value];\n      if (!entity) {\n        return undefined;\n      }\n      return entity.state;\n    }\n\n    return value;\n  }\n\n  /**\n   * Clears template cache when entities change\n   */\n  clearTemplateCache() {\n    this.templateResults.clear();\n  }\n\n  /**\n   * Enforces template cache size limits to prevent memory growth\n   */\n  enforceTemplateCacheLimit() {\n    if (this.templateResults.size <= this.templateCacheLimit) {\n      return;\n    }\n\n    // Convert to array and sort by timestamp (oldest first)\n    const cacheEntries = Array.from(this.templateResults.entries())\n      .sort((a, b) => a[1].timestamp - b[1].timestamp);\n\n    // Remove oldest entries until we're under the limit\n    const entriesToRemove = cacheEntries.length - this.templateCacheLimit;\n    for (let i = 0; i < entriesToRemove; i++) {\n      this.templateResults.delete(cacheEntries[i][0]);\n    }\n  }\n\n  /**\n   * Checks if the current config contains any templates\n   * @param {Object} config - Configuration object\n   * @returns {boolean} - Whether config contains templates\n   */\n  hasTemplatesInConfig(config: any): boolean {\n    if (!config) return false;\n    \n    // Check common template-enabled properties\n    const templateProperties = [\n      'target_date', 'creation_date', 'title', 'subtitle',\n      'text_color', 'background_color', 'progress_color', 'primary_color', 'secondary_color'\n    ];\n    \n    return templateProperties.some(prop => \n      config[prop] && this.isTemplate(config[prop])\n    );\n  }\n\n  /**\n   * Escapes HTML special characters to prevent XSS and ensure proper display\n   * @param {*} text - Text to escape\n   * @returns {string} - Escaped text\n   */\n  escapeHtml(text: string): string {\n    if (text == null || text === undefined) return '';\n    return String(text)\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#39;');\n  }\n}","import { TemplateService } from './TemplateService';\nimport { HomeAssistant, CountdownState, CardConfig } from '../types/index';\nimport { TimerEntityService } from './Timer';\n\n/**\n * CountdownService - Enhanced with Alexa Timer support\n * Handles countdown calculations and time unit management\n * Provides clean separation of countdown logic from presentation\n */\nexport class CountdownService {\n  private templateService: any;\n  private dateParser: any;\n  private timeRemaining: CountdownState;\n  private expired: boolean;\n  // Cache last selected smart timer (for autodiscovery finished display - Alexa or Google)\n  private lastAlexaTimerData: any | null;\n\n  constructor(templateService: any, dateParser: any) {\n    this.templateService = templateService;\n    this.dateParser = dateParser;\n    this.timeRemaining = { months: 0, days: 0, hours: 0, minutes: 0, seconds: 0, total: 0 };\n    this.expired = false;\n    this.lastAlexaTimerData = null;\n  }\n\n  /**\n   * Updates the countdown based on current configuration (enhanced for Alexa)\n   * @param {Object} config - Card configuration\n   * @param {Object} hass - Home Assistant object\n   * @returns {Promise<Object>} - Time remaining object\n   */\n  async updateCountdown(config: CardConfig, hass: HomeAssistant | null): Promise<CountdownState> {\n    try {\n      // TIMER ENTITY SUPPORT (including Alexa timers)\n      if (config.timer_entity && hass) {\n        const timerData = TimerEntityService.getTimerData(config.timer_entity, hass);\n        if (timerData) {\n          // Convert TimerData to CountdownState\n          this.timeRemaining = this._timerDataToCountdownState(timerData);\n          this.expired = TimerEntityService.isTimerExpired(timerData);\n          return this.timeRemaining;\n        }\n      }\n      \n          // AUTO-DISCOVERY: Try smart assistant timers if enabled\n    if (!config.timer_entity && (config.auto_discover_alexa || config.auto_discover_google) && hass) {\n      let smartTimers: string[] = [];\n      \n      // Discover Alexa timers if enabled\n      if (config.auto_discover_alexa) {\n        const alexaTimers = TimerEntityService.discoverAlexaTimers(hass);\n        smartTimers.push(...alexaTimers);\n      }\n      \n      // Discover Google Home timers if enabled\n      if (config.auto_discover_google) {\n        const googleTimers = TimerEntityService.discoverGoogleTimers(hass);\n        smartTimers.push(...googleTimers);\n      }\n      \n      if (smartTimers.length > 0) {\n        let chosen: string | undefined = smartTimers.find(entityId => {\n          const t = TimerEntityService.getTimerData(entityId, hass);\n          return t && t.isActive;\n        });\n        if (!chosen) {\n          chosen = smartTimers.find(entityId => {\n            const t = TimerEntityService.getTimerData(entityId, hass);\n            return t && t.isPaused;\n          });\n        }\n        if (!chosen) {\n          chosen = smartTimers.find(entityId => {\n            const t = TimerEntityService.getTimerData(entityId, hass);\n            return t && t.finished;\n          });\n        }\n        if (chosen) {\n          const timerData = TimerEntityService.getTimerData(chosen, hass);\n          if (timerData) {\n            // cache for later finished display when list becomes empty (works for both Alexa and Google)\n            this.lastAlexaTimerData = timerData;\n            this.timeRemaining = this._timerDataToCountdownState(timerData);\n            this.expired = TimerEntityService.isTimerExpired(timerData);\n            return this.timeRemaining;\n          }\n        }\n        // No chosen; if we have cached data and it's finished, return finished state\n        if (this.lastAlexaTimerData && TimerEntityService.isTimerExpired(this.lastAlexaTimerData)) {\n          this.timeRemaining = this._timerDataToCountdownState(this.lastAlexaTimerData);\n          this.expired = true;\n          return this.timeRemaining;\n        }\n      }\n      // No active or paused timers - clear state\n      this.lastAlexaTimerData = null;\n      this.timeRemaining = { months: 0, days: 0, hours: 0, minutes: 0, seconds: 0, total: 0 };\n      this.expired = false;\n      return this.timeRemaining;\n    }\n      \n      if (!config.target_date) return this.timeRemaining;\n      \n      const now = new Date().getTime();\n      const targetDateValue = await this.templateService.resolveValue(config.target_date);\n      \n      if (!targetDateValue) {\n        return this.timeRemaining;\n      }\n      \n      // Use the helper method for consistent date parsing\n      const targetDate = this.dateParser.parseISODate(targetDateValue);\n      \n      if (isNaN(targetDate)) {\n        return this.timeRemaining;\n      }\n      \n      const difference = targetDate - now;\n\n      if (difference > 0) {\n        // Calculate time units based on what's enabled - cascade disabled units into enabled ones\n        const { show_months, show_days, show_hours, show_minutes, show_seconds } = config;\n        \n        let totalMilliseconds = difference;\n        let months = 0, days = 0, hours = 0, minutes = 0, seconds = 0;\n        \n        // Find the largest enabled unit and calculate everything from there\n        if (show_months) {\n          months = Math.floor(totalMilliseconds / (1000 * 60 * 60 * 24 * 30.44)); // Average month length\n          totalMilliseconds %= (1000 * 60 * 60 * 24 * 30.44);\n        }\n        \n        if (show_days) {\n          days = Math.floor(totalMilliseconds / (1000 * 60 * 60 * 24));\n          totalMilliseconds %= (1000 * 60 * 60 * 24);\n        } else if (show_months && !show_days) {\n          // If days are disabled but months are enabled, add days to months\n          const extraDays = Math.floor(totalMilliseconds / (1000 * 60 * 60 * 24));\n          months += Math.floor(extraDays / 30.44);\n          totalMilliseconds %= (1000 * 60 * 60 * 24);\n        }\n        \n        if (show_hours) {\n          hours = Math.floor(totalMilliseconds / (1000 * 60 * 60));\n          totalMilliseconds %= (1000 * 60 * 60);\n        } else if ((show_months || show_days) && !show_hours) {\n          // If hours are disabled but larger units are enabled, add hours to the largest enabled unit\n          const extraHours = Math.floor(totalMilliseconds / (1000 * 60 * 60));\n          if (show_days) {\n            days += Math.floor(extraHours / 24);\n          } else if (show_months) {\n            months += Math.floor(extraHours / (24 * 30.44));\n          }\n          totalMilliseconds %= (1000 * 60 * 60);\n        }\n        \n        if (show_minutes) {\n          minutes = Math.floor(totalMilliseconds / (1000 * 60));\n          totalMilliseconds %= (1000 * 60);\n        } else if ((show_months || show_days || show_hours) && !show_minutes) {\n          // If minutes are disabled but larger units are enabled, add minutes to the largest enabled unit\n          const extraMinutes = Math.floor(totalMilliseconds / (1000 * 60));\n          if (show_hours) {\n            hours += Math.floor(extraMinutes / 60);\n          } else if (show_days) {\n            days += Math.floor(extraMinutes / (60 * 24));\n          } else if (show_months) {\n            months += Math.floor(extraMinutes / (60 * 24 * 30.44));\n          }\n          totalMilliseconds %= (1000 * 60);\n        }\n        \n        if (show_seconds) {\n          seconds = Math.floor(totalMilliseconds / 1000);\n        } else if ((show_months || show_days || show_hours || show_minutes) && !show_seconds) {\n          // If seconds are disabled but larger units are enabled, add seconds to the largest enabled unit\n          const extraSeconds = Math.floor(totalMilliseconds / 1000);\n          if (show_minutes) {\n            minutes += Math.floor(extraSeconds / 60);\n          } else if (show_hours) {\n            hours += Math.floor(extraSeconds / (60 * 60));\n          } else if (show_days) {\n            days += Math.floor(extraSeconds / (60 * 60 * 24));\n          } else if (show_months) {\n            months += Math.floor(extraSeconds / (60 * 60 * 24 * 30.44));\n          }\n        }\n\n        this.timeRemaining = { months, days, hours, minutes, seconds, total: difference };\n        this.expired = false;\n      } else {\n        this.timeRemaining = { months: 0, days: 0, hours: 0, minutes: 0, seconds: 0, total: 0 };\n        this.expired = true;\n      }\n      \n      return this.timeRemaining;\n    } catch (error) {\n      return this.timeRemaining;\n    }\n  }\n\n  /**\n   * Calculates progress percentage (enhanced for Alexa and Google Home)\n   * @param {Object} config - Card configuration\n   * @param {Object} hass - Home Assistant object\n   * @returns {Promise<number>} - Progress percentage (0-100)\n   */\n  async calculateProgress(config: CardConfig, hass: HomeAssistant | null): Promise<number> {\n    // TIMER ENTITY SUPPORT (including Alexa and Google timers)\n    if (config.timer_entity && hass) {\n      const timerData = TimerEntityService.getTimerData(config.timer_entity, hass);\n      if (!timerData) return 0;\n      return timerData.progress;\n    }\n    \n    // AUTO-DISCOVERY: Try smart assistant timers if enabled\n    if (!config.timer_entity && (config.auto_discover_alexa || config.auto_discover_google) && hass) {\n      let smartTimers: string[] = [];\n      \n      // Discover Alexa timers if enabled\n      if (config.auto_discover_alexa) {\n        const alexaTimers = TimerEntityService.discoverAlexaTimers(hass);\n        smartTimers.push(...alexaTimers);\n      }\n      \n      // Discover Google Home timers if enabled\n      if (config.auto_discover_google) {\n        const googleTimers = TimerEntityService.discoverGoogleTimers(hass);\n        smartTimers.push(...googleTimers);\n      }\n      \n      if (smartTimers.length > 0) {\n        let chosen: string | undefined = smartTimers.find(entityId => {\n          const t = TimerEntityService.getTimerData(entityId, hass);\n          return t && t.isActive;\n        });\n        if (!chosen) {\n          chosen = smartTimers.find(entityId => {\n            const t = TimerEntityService.getTimerData(entityId, hass);\n            return t && t.isPaused;\n          });\n        }\n        if (!chosen) {\n          chosen = smartTimers.find(entityId => {\n            const t = TimerEntityService.getTimerData(entityId, hass);\n            return t && t.finished;\n          });\n        }\n        if (chosen) {\n          const timerData = TimerEntityService.getTimerData(chosen, hass);\n          if (timerData) return timerData.progress;\n        }\n      }\n    }\n    \n    const targetDateValue = await this.templateService.resolveValue(config.target_date);\n    if (!targetDateValue) return 0;\n    \n    // Use the helper method for consistent date parsing\n    const targetDate = this.dateParser.parseISODate(targetDateValue);\n    const now = Date.now();\n    \n    let creationDate;\n    if (config.creation_date) {\n      const creationDateValue = await this.templateService.resolveValue(config.creation_date);\n      \n      if (creationDateValue) {\n        // Use the helper method for consistent date parsing\n        creationDate = this.dateParser.parseISODate(creationDateValue);\n      } else {\n        creationDate = now;\n      }\n    } else {\n      creationDate = now; // Fallback to now if somehow no creation date\n    }\n    \n    const totalDuration = targetDate - creationDate;\n    if (totalDuration <= 0) return 100;\n    \n    const elapsed = now - creationDate;\n    const progress = Math.min(100, Math.max(0, (elapsed / totalDuration) * 100));\n    \n    return this.expired ? 100 : progress;\n  }\n\n  /**\n   * Gets the main display value and label (enhanced for Alexa and Google Home)\n   * @param {Object} config - Card configuration\n   * @param {Object} hass - Home Assistant object (NEW parameter)\n   * @returns {Object} - Object with value and label properties\n   */\n  getMainDisplay(config: CardConfig, hass?: HomeAssistant | null): { value: string; label: string } {\n    // TIMER ENTITY SUPPORT (including Alexa and Google timers)\n    if (config.timer_entity && hass) {\n      const timerData = TimerEntityService.getTimerData(config.timer_entity, hass);\n      if (timerData) {\n        const { hours, minutes, seconds } = this.timeRemaining;\n        \n        // Special handling for smart assistant timers\n        if (timerData.isAlexaTimer || timerData.isGoogleTimer) {\n          if (TimerEntityService.isTimerExpired(timerData)) {\n            return { value: '', label: TimerEntityService.getTimerSubtitle(timerData, false) };\n          }\n          if (hours > 0) return { value: hours.toString(), label: hours === 1 ? 'hour left' : 'hours left' };\n          if (minutes > 0) return { value: minutes.toString(), label: minutes === 1 ? 'minute left' : 'minutes left' };\n          return { value: seconds.toString(), label: seconds === 1 ? 'second left' : 'seconds left' };\n        }\n        \n        // Standard timer handling\n        if (hours > 0) return { value: hours.toString(), label: hours === 1 ? 'hour' : 'hours' };\n        if (minutes > 0) return { value: minutes.toString(), label: minutes === 1 ? 'minute' : 'minutes' };\n        return { value: seconds.toString(), label: seconds === 1 ? 'second' : 'seconds' };\n      }\n    }\n    \n    // AUTO-DISCOVERY: Try smart assistant timers if enabled\n    if (!config.timer_entity && (config.auto_discover_alexa || config.auto_discover_google) && hass) {\n      let smartTimers: string[] = [];\n      \n      // Discover Alexa timers if enabled\n      if (config.auto_discover_alexa) {\n        const alexaTimers = TimerEntityService.discoverAlexaTimers(hass);\n        smartTimers.push(...alexaTimers);\n      }\n      \n      // Discover Google Home timers if enabled  \n      if (config.auto_discover_google) {\n        const googleTimers = TimerEntityService.discoverGoogleTimers(hass);\n        smartTimers.push(...googleTimers);\n      }\n      \n      if (smartTimers.length > 0) {\n        let chosen: string | undefined = smartTimers.find(entityId => {\n          const t = TimerEntityService.getTimerData(entityId, hass);\n          return t && t.isActive;\n        });\n        if (!chosen) {\n          chosen = smartTimers.find(entityId => {\n            const t = TimerEntityService.getTimerData(entityId, hass);\n            return t && t.isPaused;\n          });\n        }\n        if (!chosen) {\n          chosen = smartTimers.find(entityId => {\n            const t = TimerEntityService.getTimerData(entityId, hass);\n            return t && t.finished;\n          });\n        }\n        if (chosen) {\n          const timerData = TimerEntityService.getTimerData(chosen, hass);\n          if (timerData) {\n            // cache for finished view if list empties out later (works for both Alexa and Google)\n            this.lastAlexaTimerData = timerData;\n            // Update time remaining for proper display calculation\n            this.timeRemaining = this._timerDataToCountdownState(timerData);\n            const { hours, minutes, seconds } = this.timeRemaining;\n            if (TimerEntityService.isTimerExpired(timerData)) {\n              return { value: '', label: TimerEntityService.getTimerSubtitle(timerData, false) };\n            }\n            if (hours > 0) return { value: hours.toString(), label: hours === 1 ? 'hour left' : 'hours left' };\n            if (minutes > 0) return { value: minutes.toString(), label: minutes === 1 ? 'minute left' : 'minutes left' };\n            return { value: seconds.toString(), label: seconds === 1 ? 'second left' : 'seconds left' };\n          }\n        }\n        // No chosen timer; if we have a cached one that's finished, show its finished label\n        if (this.lastAlexaTimerData && TimerEntityService.isTimerExpired(this.lastAlexaTimerData)) {\n          return { value: '', label: TimerEntityService.getTimerSubtitle(this.lastAlexaTimerData, false) };\n        }\n      }\n    }\n    \n    const { show_months, show_days, show_hours, show_minutes, show_seconds } = config;\n    const { months, days, hours, minutes, seconds } = this.timeRemaining;\n    \n    if (this.expired) {\n      // For auto-discovered smart assistant timers, prefer timer-style expired text and cached label if available\n      if (config.auto_discover_alexa || config.auto_discover_google) {\n        if (this.lastAlexaTimerData) {\n          return { value: '', label: TimerEntityService.getTimerSubtitle(this.lastAlexaTimerData, false) };\n        }\n        return { value: '', label: 'Timer complete' };\n      }\n      return { value: 'Done', label: 'Completed!' };\n    }\n    \n    // Show the largest time unit that is enabled and has a value > 0\n    if (show_months && months > 0) {\n      return { value: months.toString(), label: months === 1 ? 'month left' : 'months left' };\n    } else if (show_days && days > 0) {\n      return { value: days.toString(), label: days === 1 ? 'day left' : 'days left' };\n    } else if (show_hours && hours > 0) {\n      return { value: hours.toString(), label: hours === 1 ? 'hour left' : 'hours left' };\n    } else if (show_minutes && minutes > 0) {\n      return { value: minutes.toString(), label: minutes === 1 ? 'minute left' : 'minutes left' };\n    } else if (show_seconds && seconds >= 0) {\n      return { value: seconds.toString(), label: seconds === 1 ? 'second left' : 'seconds left' };\n    }\n    \n    return { value: '0', label: 'seconds left' };\n  }\n\n  /**\n   * Gets the subtitle text showing time breakdown (enhanced for Alexa and Google Home)\n   * @param {Object} config - Card configuration\n   * @param {Object} hass - Home Assistant object\n   * @returns {string} - Formatted subtitle text\n   */\n  getSubtitle(config: CardConfig, hass: HomeAssistant | null): string {\n    // TIMER ENTITY SUPPORT (Handles explicit entity)\n    if (config.timer_entity && hass) {\n      const timerData = TimerEntityService.getTimerData(config.timer_entity, hass);\n      if (timerData) {\n        // For smart assistant timers, always use their specific subtitle logic\n        if (timerData.isAlexaTimer || timerData.isGoogleTimer) {\n          return TimerEntityService.getTimerSubtitle(timerData, config.show_seconds !== false);\n        }\n        // For standard HA timers, use the timer subtitle if available\n        return TimerEntityService.getTimerSubtitle(timerData, config.show_seconds !== false);\n      }\n      return 'Timer not found';\n    }\n    \n    // --- REVISED AUTO-DISCOVERY LOGIC ---\n    if (!config.timer_entity && (config.auto_discover_alexa || config.auto_discover_google) && hass) {\n      let smartTimers: string[] = [];\n      if (config.auto_discover_alexa) smartTimers.push(...TimerEntityService.discoverAlexaTimers(hass));\n      if (config.auto_discover_google) smartTimers.push(...TimerEntityService.discoverGoogleTimers(hass));\n\n      if (smartTimers.length > 0) {\n        let chosen: string | undefined = smartTimers.find(entityId => {\n          const t = TimerEntityService.getTimerData(entityId, hass);\n          return t && t.isActive;\n        });\n        if (!chosen) {\n          chosen = smartTimers.find(entityId => {\n            const t = TimerEntityService.getTimerData(entityId, hass);\n            return t && t.isPaused;\n          });\n        }\n        if (!chosen) {\n          chosen = smartTimers.find(entityId => {\n            const t = TimerEntityService.getTimerData(entityId, hass);\n            return t && t.finished;\n          });\n        }\n\n        // Case 1: An active, paused, or finished timer was chosen\n        if (chosen) {\n          const timerData = TimerEntityService.getTimerData(chosen, hass);\n          if (timerData) {\n            this.lastAlexaTimerData = timerData; // Cache for finished fallback\n            this.timeRemaining = this._timerDataToCountdownState(timerData);\n            return TimerEntityService.getTimerSubtitle(timerData, config.show_seconds !== false);\n          }\n        }\n\n        // Case 2: No active timer, but we have a cached one that just finished\n        if (this.lastAlexaTimerData && TimerEntityService.isTimerExpired(this.lastAlexaTimerData)) {\n          return TimerEntityService.getTimerSubtitle(this.lastAlexaTimerData, config.show_seconds !== false);\n        }\n\n        // Case 3: No active timer and no recently finished timer.\n        // This means the entity exists but has no running timers. Provide a specific message.\n        const firstDiscovered = TimerEntityService.getTimerData(smartTimers[0], hass);\n        if (firstDiscovered) {\n            // Return the \"no timers\" state from the specific service (Alexa or Google)\n            return TimerEntityService.getTimerSubtitle(firstDiscovered, config.show_seconds !== false);\n        }\n      }\n      \n      // Case 4: No smart timer entities were discovered at all.\n      return 'No timers found';\n    }\n    \n    // --- FALLBACK TO STANDARD COUNTDOWN ---\n    if (this.expired) {\n      const { expired_text = 'Completed!' } = config;\n      return expired_text;\n    }\n    \n    const { months, days, hours, minutes, seconds } = this.timeRemaining || { months: 0, days: 0, hours: 0, minutes: 0, seconds: 0 };\n    const { show_months, show_days, show_hours, show_minutes, show_seconds, compact_format } = config;\n    \n    const parts = [];\n    \n    if (show_months && months > 0) parts.push({ value: months, unit: months === 1 ? 'month' : 'months' });\n    if (show_days && days > 0) parts.push({ value: days, unit: days === 1 ? 'day' : 'days' });\n    if (show_hours && hours > 0) parts.push({ value: hours, unit: hours === 1 ? 'hour' : 'hours' });\n    if (show_minutes && minutes > 0) parts.push({ value: minutes, unit: minutes === 1 ? 'minute' : 'minutes' });\n    if (show_seconds && seconds > 0) parts.push({ value: seconds, unit: seconds === 1 ? 'second' : 'seconds' });\n    \n    if (parts.length === 0) {\n      if (show_seconds) return `0 seconds`;\n      return 'Starting...';\n    }\n    \n    // If only one unit, always show full format\n    if (parts.length === 1) return `${parts[0].value} ${parts[0].unit}`;\n    \n    // For 2+ units, decide format:\n    // - If compact_format is explicitly true, use compact\n    // - If compact_format is explicitly false, use full\n    // - If compact_format is undefined (auto), use compact only if 3+ units\n    const useCompact = compact_format === true || (compact_format !== false && parts.length >= 3);\n    \n    if (useCompact) {\n      const compact = parts.map(p => `${p.value}${p.unit.charAt(0)}`).join(' ');\n      return compact;\n    }\n    \n    // Full format for 2 units\n    return parts.map(p => `${p.value} ${p.unit}`).join(' ');\n  }  /**\n   * Converts TimerData to CountdownState for unified interface\n   */\n  private _timerDataToCountdownState(timerData: any): CountdownState {\n    return {\n      months: 0,\n      days: 0,\n      hours: Math.floor(timerData.remaining / 3600),\n      minutes: Math.floor((timerData.remaining % 3600) / 60),\n      seconds: Math.floor(timerData.remaining % 60),\n      total: timerData.remaining * 1000 // ms for consistency\n    };\n  }\n\n  /**\n   * Gets current time remaining\n   * @returns {Object} - Time remaining object\n   */\n  getTimeRemaining(): CountdownState {\n    return this.timeRemaining;\n  }\n\n  /**\n   * Gets expired status\n   * @returns {boolean} - Whether countdown has expired\n   */\n  isExpired(): boolean {\n    return this.expired;\n  }\n\n  /**\n   * Gets available Alexa timers for debugging/info\n   * @param {Object} hass - Home Assistant object\n   * @returns {string[]} - Array of Alexa timer entity IDs\n   */\n  getAvailableAlexaTimers(hass: HomeAssistant | null): string[] {\n    if (!hass) return [];\n    return TimerEntityService.discoverAlexaTimers(hass);\n  }\n\n  /**\n   * Gets available Google Home timers for debugging/info\n   * @param {Object} hass - Home Assistant object\n   * @returns {string[]} - Array of Google Home timer entity IDs\n   */\n  getAvailableGoogleTimers(hass: HomeAssistant | null): string[] {\n    if (!hass) return [];\n    return TimerEntityService.discoverGoogleTimers(hass);\n  }\n\n  /**\n   * Get the current timer entity being used (for default actions)\n   */\n  getCurrentTimerEntity(config: any, hass: any): string | null {\n    // If explicit timer entity is configured, use it\n    if (config.timer_entity) {\n      return config.timer_entity;\n    }\n\n    // If auto-discovery is enabled, try to find the best smart assistant timer\n    if ((config.auto_discover_alexa || config.auto_discover_google) && hass) {\n      let smartTimers: string[] = [];\n      \n      // Discover Alexa timers if enabled\n      if (config.auto_discover_alexa) {\n        const alexaTimers = TimerEntityService.discoverAlexaTimers(hass);\n        smartTimers.push(...alexaTimers);\n      }\n      \n      // Discover Google Home timers if enabled\n      if (config.auto_discover_google) {\n        const googleTimers = TimerEntityService.discoverGoogleTimers(hass);\n        smartTimers.push(...googleTimers);\n      }\n      \n      if (smartTimers.length > 0) {\n        // Find the first active timer, or return the first timer if none are active\n        for (const entityId of smartTimers) {\n          const timerData = TimerEntityService.getTimerData(entityId, hass);\n          if (timerData && timerData.isActive) {\n            return entityId;\n          }\n        }\n        // No active timers found, return the first one\n        return smartTimers[0];\n      }\n    }\n\n    return null;\n  }\n}","/**\n * StyleManager - Handles styling calculations and CSS processing\n * Provides dynamic sizing, proportional scaling, and style management\n */\nexport class StyleManager {\n  // Constants for icon and stroke size limits\n  static MIN_ICON_SIZE = 40;\n  static MAX_ICON_SIZE = 300;  // Increased from 120 to 300\n  static MIN_STROKE = 4;\n  static MAX_STROKE = 50;      // Increased from 20 to 50\n\n  private cache: {\n    dynamicIconSize: number | null;\n    dynamicStrokeWidth: number | null;\n    customStyles: any | null;\n    lastConfigHash: string | null;\n    lastIconConfigHash?: string | null;\n    lastStrokeConfigHash?: string | null;\n  };\n\n  constructor() {\n    this.cache = {\n      dynamicIconSize: null,\n      dynamicStrokeWidth: null,\n      customStyles: null,\n      lastConfigHash: null\n    };\n  }\n\n  /**\n   * Processes styles array into CSS string\n   * @param {Array} styles - Array of style objects or strings\n   * @returns {string} - CSS string\n   */\n  processStyles(styles: any[]): string {\n    if (!styles || !Array.isArray(styles)) return '';\n    \n    return styles.map(style => {\n      try {\n        if (typeof style === 'string') {\n          return style;\n        } else if (typeof style === 'object' && style !== null) {\n          return Object.entries(style)\n            .map(([prop, value]) => `${prop}: ${value}`)\n            .join('; ');\n        }\n        return '';\n      } catch (e) {\n        return '';\n      }\n    }).join('; ');\n  }\n\n  /**\n   * Builds styles object from configuration\n   * @param {Object} config - Card configuration\n   * @returns {Object} - Processed styles object\n   */\n  buildStylesObject(config: any): any {\n    // Use cached value if available and config hasn't changed\n    const configHash = JSON.stringify(config.styles || {});\n    if (this.cache.customStyles !== null && this.cache.lastConfigHash === configHash) {\n      return this.cache.customStyles;\n    }\n\n    const { styles = {} } = config;\n    \n    try {\n      const processedStyles = {\n        card: this.processStyles(styles.card),\n        title: this.processStyles(styles.title),\n        subtitle: this.processStyles(styles.subtitle),\n        progress_circle: this.processStyles(styles.progress_circle)\n      };\n\n      this.cache.customStyles = processedStyles;\n      this.cache.lastConfigHash = configHash;\n      return processedStyles;\n    } catch (e) {\n      this.cache.customStyles = {\n        card: '',\n        title: '',\n        subtitle: '',\n        progress_circle: ''\n      };\n      return this.cache.customStyles;\n    }\n  }\n\n  /**\n   * Internal helper to get card dimensions based on width, height, and aspect ratio\n   */\n  _getCardDimensions(width: any, height: any, aspect_ratio: any): any {\n    const defaultWidth = 300;\n    const defaultHeight = 150;\n    let cardWidth = defaultWidth;\n    let cardHeight = defaultHeight;\n    if (width && height) {\n      const parsedW = this.parseDimension(width);\n      const parsedH = this.parseDimension(height);\n      cardWidth = parsedW || defaultWidth;\n      cardHeight = parsedH || defaultHeight;\n    } else if (width && aspect_ratio) {\n      const parsedW = this.parseDimension(width);\n      cardWidth = parsedW || defaultWidth;\n      const [ratioW, ratioH] = aspect_ratio.split('/').map(parseFloat);\n      if (!isNaN(ratioW) && !isNaN(ratioH) && ratioW > 0) {\n        cardHeight = cardWidth * (ratioH / ratioW);\n      }\n    } else if (height && aspect_ratio) {\n      const parsedH = this.parseDimension(height);\n      cardHeight = parsedH || defaultHeight;\n      const [ratioW, ratioH] = aspect_ratio.split('/').map(parseFloat);\n      if (!isNaN(ratioW) && !isNaN(ratioH) && ratioH > 0) {\n        cardWidth = cardHeight * (ratioW / ratioH);\n      }\n    } else if (aspect_ratio) {\n      const [ratioW, ratioH] = aspect_ratio.split('/').map(parseFloat);\n      if (!isNaN(ratioW) && !isNaN(ratioH) && ratioW > 0) {\n        cardHeight = defaultWidth * (ratioH / ratioW);\n      }\n      cardWidth = defaultWidth;\n    }\n    if (!cardWidth || isNaN(cardWidth) || cardWidth <= 0) cardWidth = defaultWidth;\n    if (!cardHeight || isNaN(cardHeight) || cardHeight <= 0) cardHeight = defaultHeight;\n    return { cardWidth, cardHeight };\n  }\n\n  /**\n   * Calculate dynamic icon size based on card dimensions - now truly proportional\n   * @param {*} width - Card width\n   * @param {*} height - Card height\n   * @param {string} aspect_ratio - Aspect ratio string\n   * @param {*} icon_size - Explicit icon size\n   * @returns {number} - Calculated icon size in pixels\n   */\n  calculateDynamicIconSize(width: any, height: any, aspect_ratio: any, icon_size: any): number {\n    // Use cached value if available and config hasn't changed\n    const configKey = JSON.stringify({ width, height, aspect_ratio, icon_size });\n    if (this.cache.dynamicIconSize !== null && this.cache.lastIconConfigHash === configKey) {\n      return this.cache.dynamicIconSize;\n    }\n\n    try {\n      const { cardWidth, cardHeight } = this._getCardDimensions(width, height, aspect_ratio);\n      const minDimension = Math.min(cardWidth, cardHeight);\n      const proportionalSize = minDimension * 0.4;\n      let size = proportionalSize;\n\n      // Respect explicit icon_size if provided, otherwise use proportional\n      if (icon_size && icon_size !== '100px') {\n        const baseSize = typeof icon_size === 'string' ?\n          parseInt(icon_size.replace('px', '')) :\n          (typeof icon_size === 'number' ? icon_size : proportionalSize);\n        // If explicit size is provided, use it directly (within max limit)\n        size = (!isNaN(baseSize)) ? baseSize : proportionalSize;\n      }\n\n      this.cache.dynamicIconSize = Math.max(StyleManager.MIN_ICON_SIZE, Math.min(size, StyleManager.MAX_ICON_SIZE));\n      this.cache.lastIconConfigHash = configKey;\n      return this.cache.dynamicIconSize;\n    } catch (error) {\n      this.cache.dynamicIconSize = StyleManager.MIN_ICON_SIZE; // Safe fallback\n      return this.cache.dynamicIconSize;\n    }\n  }\n\n  /**\n   * Calculate dynamic stroke width based on icon size\n   * @param {number} iconSize - Icon size in pixels\n   * @param {*} stroke_width - Explicit stroke width\n   * @returns {number} - Calculated stroke width\n   */\n  calculateDynamicStrokeWidth(iconSize: any, stroke_width: any): number {\n    // Use cached value if available and config hasn't changed\n    const configKey = JSON.stringify({ iconSize, stroke_width });\n    if (this.cache.dynamicStrokeWidth !== null && this.cache.lastStrokeConfigHash === configKey) {\n      return this.cache.dynamicStrokeWidth;\n    }\n\n    try {\n      // If explicit stroke_width is provided, use it directly\n      if (stroke_width && typeof stroke_width === 'number') {\n        this.cache.dynamicStrokeWidth = Math.max(StyleManager.MIN_STROKE, Math.min(stroke_width, StyleManager.MAX_STROKE));\n      } else {\n        // Otherwise calculate proportional stroke based on icon size\n        const ratio = 0.15;\n        const calculated = Math.round(iconSize * ratio);\n        this.cache.dynamicStrokeWidth = Math.max(StyleManager.MIN_STROKE, Math.min(calculated, StyleManager.MAX_STROKE));\n      }\n      \n      this.cache.lastStrokeConfigHash = configKey;\n      return this.cache.dynamicStrokeWidth;\n    } catch (error) {\n      this.cache.dynamicStrokeWidth = StyleManager.MIN_STROKE; // Safe fallback\n      return this.cache.dynamicStrokeWidth;\n    }\n  }\n\n  /**\n   * Calculate proportional font sizes based on card dimensions\n   * @param {*} width - Card width\n   * @param {*} height - Card height\n   * @param {string} aspect_ratio - Aspect ratio string\n   * @returns {Object} - Object with font sizes and dimensions\n   */\n  calculateProportionalSizes(width: any, height: any, aspect_ratio: any): any {\n    try {\n      const { cardWidth, cardHeight } = this._getCardDimensions(width, height, aspect_ratio);\n      const defaultArea = 300 * 150;\n      const scaleFactor = Math.sqrt((cardWidth * cardHeight) / defaultArea);\n\n      return {\n        titleSize: Math.max(1.2, Math.min(2.2, 1.6 * scaleFactor)),\n        subtitleSize: Math.max(0.9, Math.min(1.4, 1.1 * scaleFactor)),\n        cardWidth,\n        cardHeight\n      };\n    } catch (error) {\n      return { titleSize: 1.6, subtitleSize: 1.1, cardWidth: 300, cardHeight: 150 };\n    }\n  }\n\n  /**\n   * Helper to parse dimension strings (e.g., \"200px\", \"100%\") to numbers\n   * @param {*} dimension - Dimension value to parse\n   * @returns {number|null} - Parsed dimension in pixels\n   */\n  parseDimension(dimension: any): number | null {\n    try {\n      if (typeof dimension === 'number') return dimension;\n      if (typeof dimension !== 'string') return null;\n      // Normalize string for case-insensitive matching\n      const dimStr = dimension.toLowerCase();\n      // Handle percentage values - assume 300px base for calculations\n      if (dimStr.includes('%')) {\n        const percent = parseFloat(dimStr.replace('%', ''));\n        return isNaN(percent) ? null : (percent / 100) * 300; // 300px as base\n      }\n      // Handle pixel values\n      if (dimStr.includes('px')) {\n        const pixels = parseFloat(dimStr.replace('px', ''));\n        return isNaN(pixels) ? null : pixels;\n      }\n      // Try to parse as number\n      const parsed = parseFloat(dimStr);\n      return isNaN(parsed) ? null : parsed;\n    } catch (error) {\n      return null;\n    }\n  }\n\n  /**\n   * Generates card dimensions CSS based on configuration\n   * @param {*} width - Card width\n   * @param {*} height - Card height\n   * @param {string} aspect_ratio - Aspect ratio string\n   * @returns {Array} - Array of CSS style strings\n   */\n  generateCardDimensionStyles(width: any, height: any, aspect_ratio: any): string[] {\n    const cardStyles = [];\n    \n    // Apply width if specified\n    if (width) {\n      const formattedWidth = this._formatDimensionValue(width);\n      if (formattedWidth) {\n        cardStyles.push(`width: ${formattedWidth}`);\n      }\n    }\n    \n    // Apply height if specified\n    if (height) {\n      const formattedHeight = this._formatDimensionValue(height);\n      if (formattedHeight) {\n        cardStyles.push(`height: ${formattedHeight}`);\n      }\n    } else if (aspect_ratio && !height) {\n      // Use aspect-ratio if height not specified\n      cardStyles.push(`aspect-ratio: ${aspect_ratio}`);\n    }\n    \n    // Add a minimum height if no height or aspect ratio is specified\n    if (!height && !aspect_ratio) {\n      cardStyles.push('min-height: 120px');\n    }\n\n    return cardStyles;\n  }\n\n  /**\n   * Helper method to format dimension values with proper units\n   * @param {*} value - The dimension value (string or number)\n   * @returns {string|null} - Formatted CSS value or null if invalid\n   */\n  private _formatDimensionValue(value: any): string | null {\n    if (!value) return null;\n    \n    const strValue = String(value).trim();\n    \n    // If it already has units (px, %, em, rem, vh, vw, etc.), use as-is\n    if (/^[\\d.]+\\s*(px|%|em|rem|vh|vw|vmin|vmax|ch|ex)$/i.test(strValue)) {\n      return strValue;\n    }\n    \n    // If it's a pure number, add 'px' unit\n    const numValue = parseFloat(strValue);\n    if (!isNaN(numValue)) {\n      return `${numValue}px`;\n    }\n    \n    // Invalid value\n    return null;\n  }\n\n  /**\n   * Clears style cache\n   */\n  clearCache() {\n    this.cache = {\n      dynamicIconSize: null,\n      dynamicStrokeWidth: null,\n      customStyles: null,\n      lastConfigHash: null\n    };\n  }\n\n  /**\n   * Public method to get card dimensions based on configuration\n   * @param {*} width - Card width\n   * @param {*} height - Card height\n   * @param {string} aspect_ratio - Aspect ratio string\n   * @returns {Object} - Object with cardWidth and cardHeight\n   */\n  getCardDimensions(width: any, height: any, aspect_ratio: any): { cardWidth: number; cardHeight: number } {\n    return this._getCardDimensions(width, height, aspect_ratio);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst t={ATTRIBUTE:1,CHILD:2,PROPERTY:3,BOOLEAN_ATTRIBUTE:4,EVENT:5,ELEMENT:6},e=t=>(...e)=>({_$litDirective$:t,values:e});class i{constructor(t){}get _$AU(){return this._$AM._$AU}_$AT(t,e,i){this._$Ct=t,this._$AM=e,this._$Ci=i}_$AS(t,e){return this.update(t,e)}update(t,e){return this.render(...e)}}export{i as Directive,t as PartType,e as directive};\n//# sourceMappingURL=directive.js.map\n","/**\n * Action Handling Code for Home Assistant\n * Consolidated from frontend and custom-card-helpers\n */\n\nimport { HomeAssistant, ActionConfig } from '../types/index';\n\n/**\n * Fire a custom event on an element\n */\nexport function fireEvent(\n  node: HTMLElement,\n  type: string,\n  detail?: any,\n  options?: { bubbles?: boolean; cancelable?: boolean; composed?: boolean }\n): void {\n  const event = new CustomEvent(type, {\n    bubbles: options?.bubbles ?? true,\n    cancelable: options?.cancelable ?? true,\n    composed: options?.composed ?? true,\n    detail,\n  });\n  node.dispatchEvent(event);\n}\n\n/**\n * Handle action execution for Home Assistant cards\n */\nexport const handleAction = (\n  node: HTMLElement,\n  _hass: HomeAssistant,\n  config: {\n    entity?: string;\n    camera_image?: string;\n    hold_action?: ActionConfig;\n    tap_action?: ActionConfig;\n    double_tap_action?: ActionConfig;\n  },\n  action: string\n): void => {\n  fireEvent(node, \"hass-action\", { config, action });\n};\n","/**\n * Consolidated action handler for Home Assistant\n * Combines directive and helper functions\n */\n\nimport { noChange } from \"lit\";\nimport { AttributePart, directive, Directive, DirectiveParameters } from \"lit/directive.js\";\nimport { ActionHandlerEvent, HomeAssistant, CardConfig } from '../types/index';\nimport { handleAction } from './handle-action';\n\ninterface ActionHandler extends HTMLElement {\n  holdTime: number;\n  bind(element: Element, options?: ActionHandlerOptions): void;\n}\n\ninterface ActionHandlerElement extends HTMLElement {\n  actionHandler?: {\n    options: ActionHandlerOptions;\n    start?: (ev: Event) => void;\n    end?: (ev: Event) => void;\n    handleEnter?: (ev: KeyboardEvent) => void;\n  };\n}\n\ntype ActionHandlerOptions = {\n  hasHold?: boolean;\n  hasDoubleClick?: boolean;\n};\n\nconst getActionHandler = (): ActionHandler | null => {\n  const body = document.body;\n  if (body.querySelector(\"action-handler\")) {\n    return body.querySelector(\"action-handler\") as ActionHandler;\n  }\n\n  const actionhandler = document.createElement(\"action-handler\");\n  body.appendChild(actionhandler);\n\n  return actionhandler as ActionHandler;\n};\n\nexport const actionHandlerBind = (\n  element: ActionHandlerElement,\n  options?: ActionHandlerOptions\n) => {\n  const actionhandler: ActionHandler | null = getActionHandler();\n  if (!actionhandler) {\n    return;\n  }\n  actionhandler.bind(element, options);\n};\n\nexport const actionHandler = directive(\n  class extends Directive {\n    update(part: AttributePart, [options]: DirectiveParameters<this>) {\n      actionHandlerBind(part.element as ActionHandlerElement, options);\n      return noChange;\n    }\n\n    render(_options?: ActionHandlerOptions) {\n      return noChange;\n    }\n  }\n);\n\n/**\n * Check if an action is configured\n */\nexport function hasAction(config?: any): boolean {\n  return config !== undefined && config.action !== 'none';\n}\n\n/**\n * Create action handler with proper options\n */\nexport function createActionHandler(config: CardConfig) {\n  return actionHandler({\n    hasHold: hasAction(config.hold_action),\n    hasDoubleClick: hasAction(config.double_tap_action),\n  });\n}\n\n/**\n * Create handle action function for events\n */\nexport function createHandleAction(hass: HomeAssistant, config: CardConfig) {\n  return (ev: ActionHandlerEvent) => {\n    handleAction(ev.target as any, hass, config, ev.detail.action);\n  };\n}\n","import { LitElement, html, css, TemplateResult, CSSResult } from 'lit';\nimport { property } from 'lit/decorators.js';\n\nexport interface ValidationError {\n  field: string;\n  message: string;\n  severity: 'critical' | 'warning' | 'info';\n  suggestion?: string;\n  value?: any;\n}\n\nexport class ErrorDisplay extends LitElement {\n  @property({ type: Array }) errors: ValidationError[] = [];\n  @property({ type: String }) title: string = 'Configuration Issues';\n\n  static get styles(): CSSResult {\n    return css`\n      :host {\n        display: block;\n        font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif);\n      }\n\n      .error-container {\n        background: #332022;\n        border: 1px solid #582533ff;\n        border-radius: 1px;\n        padding: 16px;\n        margin: 8px;\n        color: #ffffff;\n      }\n\n      .error-list {\n        list-style: none;\n        padding: 0;\n        margin: 0;\n      }\n\n      .error-item {\n        margin-bottom: 8px;\n        line-height: 1.4;\n      }\n\n      .error-field {\n        font-weight: 600;\n        color: #D74133;\n      }\n    `;\n  }\n\n  render(): TemplateResult {\n    if (!this.errors || this.errors.length === 0) {\n      return html``;\n    }\n\n    // Filter out info messages, only show critical and warning\n    const relevantErrors = this.errors.filter(e => e.severity === 'critical' || e.severity === 'warning');\n    \n    if (relevantErrors.length === 0) {\n      return html``;\n    }\n\n    return html`\n      <div class=\"error-container\">\n        <ul class=\"error-list\">\n          ${relevantErrors.map(error => html`\n            <li class=\"error-item\">\n              <span class=\"error-field\">${error.field}:</span> ${error.message}\n            </li>\n          `)}\n        </ul>\n      </div>\n    `;\n  }\n}\n\n// Register the custom element\ncustomElements.define('error-display', ErrorDisplay);\n","//TimeFlowCard.ts\nimport { LitElement, html, css, TemplateResult, CSSResult } from 'lit';\nimport { property, state } from 'lit/decorators.js';\nimport { TimerEntityService } from '../services/Timer';\nimport { DateParser } from '../utils/DateParser';\nimport { ConfigValidator, ValidationResult, ValidationError } from '../utils/ConfigValidator';\nimport { TemplateService } from '../services/TemplateService';\nimport { CountdownService } from '../services/CountdownService';\nimport { StyleManager } from '../utils/StyleManager';\nimport { HomeAssistant, CountdownState, CardConfig, ActionHandlerEvent } from '../types/index';\nimport { createActionHandler, createHandleAction } from '../utils/action-handler';\nimport '../utils/ErrorDisplay';\n\nexport class TimeFlowCard extends LitElement {\n  public static async getConfigElement(): Promise<HTMLElement> {\n    return document.createElement('timeflow-card-editor');\n  }\n\n  // Reactive properties to trigger updates\n  @property({ type: Object }) hass: HomeAssistant | null = null;\n  @property({ type: Object }) config: CardConfig = this.getStubConfig();\n\n  // Internal reactive state for resolved config props and countdown state\n  @state() private _resolvedConfig: CardConfig = this.getStubConfig();\n  @state() private _progress: number = 0;\n  @state() private _countdown: CountdownState = {\n    months: 0,\n    days: 0,\n    hours: 0,\n    minutes: 0,\n    seconds: 0,\n    total: 0\n  };\n  @state() private _expired: boolean = false;\n  @state() private _validationResult: ValidationResult | null = null;\n  @state() private _initialized: boolean = false; // Track initialization\n\n  // Timer ID\n  private _timerId: ReturnType<typeof setInterval> | null = null;\n\n  // Services instances (could be injected if needed)\n  private templateService = new TemplateService();\n  private countdownService = new CountdownService(this.templateService, DateParser);\n  private styleManager = new StyleManager();\n\n  static get styles(): CSSResult {\n    return css`\n      :host {\n        display: block;\n        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;\n        color: var(--primary-text-color, #222);\n        --progress-color: var(--progress-color, #4caf50);\n      }\n      \n      /* FIXED: Set initial background immediately to prevent white flash */\n      ha-card {\n        display: flex;\n        flex-direction: column;\n        padding: 0;\n        border-radius: 22px;\n        position: relative;\n        overflow: hidden;\n        /* IMPORTANT: Set default background immediately */\n        background: var(--card-background, var(--primary-background-color, #1a1a1a));\n        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n        border: none;\n        /* REMOVED: transition that causes flash - only animate specific properties if needed */\n        /* transition: background-color 0.3s ease; */\n        min-height: 120px; /* Prevent layout shift */\n        user-select: none; /* Prevent text selection during interactions */\n      }\n      \n      /* Make card interactive when actions are configured */\n      ha-card[actionHandler] {\n        cursor: pointer;\n      }\n      \n      ha-card[actionHandler]:hover {\n        transform: translateY(-1px);\n        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);\n        transition: transform 0.2s ease, box-shadow 0.2s ease;\n      }\n      \n      ha-card[actionHandler]:active {\n        transform: translateY(0);\n        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n      }\n      \n      /* Error message styling */\n      .error {\n        color: #721c24;\n        padding: 12px;\n        border-radius: 16px;\n        white-space: pre-wrap;\n        word-break: break-word;\n      }\n      \n      /* FIXED: Only show card after initialization to prevent white flash */\n      ha-card:not(.initialized) {\n        opacity: 0;\n      }\n      \n      ha-card.initialized {\n        opacity: 1;\n        transition: opacity 0.2s ease-in;\n      }\n      \n      ha-card.expired {\n        animation: celebration 0.8s ease-in-out;\n      }\n      \n      .card-content {\n        display: flex;\n        flex-direction: column;\n        justify-content: space-between;\n        padding: 20px;\n        height: 100%;\n        /* FIXED: Ensure content has proper background inheritance */\n        background: inherit;\n      }\n      \n      .header {\n        display: flex;\n        justify-content: space-between;\n        align-items: flex-start;\n        margin-bottom: 0;\n      }\n      \n      .title-section {\n        flex: 1;\n        display: flex;\n        flex-direction: column;\n        gap: 2px;\n      }\n      \n      .title {\n        font-size: var(--timeflow-title-size, 1.5rem);\n        font-weight: 500;\n        margin: 0;\n        opacity: 0.9;\n        line-height: 1.3;\n        letter-spacing: -0.01em;\n        color: var(--timeflow-card-text-color, inherit);\n      }\n      \n      .subtitle {\n        font-size: var(--timeflow-subtitle-size, 1rem);\n        opacity: 0.65;\n        margin: 0;\n        font-weight: 400;\n        line-height: 1.2;\n        color: var(--timeflow-card-text-color, inherit);\n      }\n      \n      .progress-section {\n        flex-shrink: 0;\n        margin-left: auto;\n      }\n      \n      .content {\n        display: flex;\n        align-items: flex-end;\n        justify-content: flex-end;\n        margin-top: auto;\n        padding-top: 12px;\n      }\n      \n      .progress-circle {\n        opacity: 0.9;\n      }\n      \n      @keyframes celebration {\n        0% { transform: scale(1); }\n        50% { transform: scale(1.05); }\n        100% { transform: scale(1); }\n      }\n      \n      /* Dark mode support */\n      @media (prefers-color-scheme: dark) {\n        ha-card {\n          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n        }\n      }\n    `;\n  }\n\n  constructor() {\n    super();\n    // Initialize with proper stub config\n    const stubConfig = this.getStubConfig();\n    this.config = stubConfig;\n    this._resolvedConfig = stubConfig;\n  }\n\n  // Provide default configuration stub \n  static getStubConfig(): CardConfig {\n    return {\n      type: 'custom:timeflow-card',\n      target_date: '2026-12-31T23:59:59',\n      creation_date: '2025-12-31T23:59:59',\n      timer_entity: '',\n      title: 'New Year Countdown',\n      show_days: true,\n      show_hours: true,\n      show_minutes: true,\n      show_seconds: true,\n      progress_color: '',\n      background_color: \"\",\n      stroke_width: 15,\n      icon_size: 100,\n      expired_animation: false,\n      expired_text: 'Completed!',\n    };\n  }\n\n  // Instance method for internal use\n  getStubConfig(): CardConfig {\n    return TimeFlowCard.getStubConfig();\n  }\n\n  setConfig(config: CardConfig): void {\n    try {\n      // Validate the config with new enhanced validation\n      const validationResult = ConfigValidator.validateConfig(config);\n      this._validationResult = validationResult;\n      \n      // Determine if we should proceed with the configuration\n      if (validationResult.hasCriticalErrors) {\n        // Use safe config if available, otherwise use stub config\n        this.config = validationResult.safeConfig || this.getStubConfig();\n        this._resolvedConfig = { ...this.config };\n      } else if (validationResult.hasWarnings) {\n        // Configuration has warnings - don't proceed with normal flow\n        this.config = { ...config };\n        this._resolvedConfig = { ...config };\n        this._initialized = true; // Set as initialized to show the warning\n        this.requestUpdate();\n        return; // Don't proceed with countdown updates\n      } else {\n        // Configuration is valid\n        this.config = { ...config };\n        this._resolvedConfig = { ...config };\n      }\n      \n      this._initialized = false; // Reset initialization flag\n      this.templateService.clearTemplateCache();\n      this.styleManager.clearCache();\n      \n      // Trigger immediate update after config change\n      this._updateCountdownAndRender().then(() => {\n        this._initialized = true;\n        this.requestUpdate();\n      });\n    } catch (err) {\n      // Handle unexpected validation errors\n      \n      // Create a validation result for unexpected errors\n      this._validationResult = {\n        isValid: false,\n        errors: [{\n          field: 'config',\n          message: (err as Error).message || 'Unexpected configuration error',\n          severity: 'critical',\n          suggestion: 'Check console for details and verify your configuration syntax.',\n          value: config\n        }],\n        hasCriticalErrors: true,\n        hasWarnings: false,\n        safeConfig: this.getStubConfig()\n      };\n      \n      this.config = this.getStubConfig();\n      this._resolvedConfig = { ...this.config };\n      this._initialized = true; // Make sure we're initialized to render the error\n      \n      // Force update to show error message\n      this.requestUpdate();\n    }\n  }\n\n  // Lit lifecycle: Called when component is first updated after initial render\n  firstUpdated(): void {\n    // Set up template service with card reference\n    this.templateService.card = this;\n    \n    // FIXED: Initialize immediately on first update\n    this._updateCountdownAndRender().then(() => {\n      this._initialized = true;\n      this.requestUpdate();\n      this._startCountdownUpdates();\n    });\n  }\n\n  // Cleanup on disconnect\n  disconnectedCallback(): void {\n    super.disconnectedCallback();\n    this._stopCountdownUpdates();\n  }\n\n  updated(changedProperties: Map<string | number | symbol, unknown>): void {\n    if (changedProperties.has('hass') || changedProperties.has('config')) {\n      // Clear template caches on hass or config changes\n      this.templateService.clearTemplateCache();\n      this._updateCountdownAndRender();\n    }\n  }\n\n  /**\n   * Starts ticking the countdown every second\n   */\n  _startCountdownUpdates(): void {\n    this._stopCountdownUpdates(); // clear previous interval\n    this._timerId = setInterval(() => {\n      this._updateCountdownAndRender();\n    }, 1000);\n  }\n\n  /**\n   * Clears the countdown update timer\n   */\n  _stopCountdownUpdates(): void {\n    if (this._timerId) {\n      clearInterval(this._timerId);\n      this._timerId = null;\n    }\n  }\n\n  /**\n   * Resolves templates and updates countdown data, then requests re-render\n   */\n  async _updateCountdownAndRender() {\n    // If we have critical configuration errors, skip updates\n    if (this._validationResult?.hasCriticalErrors) return;\n\n    // Clone config for resolution\n    const resolvedConfig = { ...this.config };\n\n    // List of config keys that can be templates\n    const templateKeys = [\n      'target_date',\n      'creation_date',\n      'timer_entity',\n      'title',\n      'subtitle',\n      'text_color',\n      'background_color',\n      'progress_color',\n      'primary_color',\n      'secondary_color',\n      'expired_text'\n    ] as const;\n\n    // Resolve templates where applicable\n    for (const key of templateKeys) {\n      if (typeof resolvedConfig[key] === 'string' && this.templateService.isTemplate(resolvedConfig[key] as string)) {\n        const resolvedValue = await this.templateService.resolveValue(resolvedConfig[key] as string);\n        resolvedConfig[key] = resolvedValue || undefined;\n      }\n    }\n\n    // Store resolved config in reactive state\n    this._resolvedConfig = resolvedConfig;\n\n    // Calculate countdown data\n    await this.countdownService.updateCountdown(resolvedConfig, this.hass);\n\n    // Update countdown state\n    this._countdown = { ...this.countdownService.getTimeRemaining() };\n    this._expired = this.countdownService.isExpired();\n\n    // Calculate progress (0-100)\n    this._progress = await this.countdownService.calculateProgress(resolvedConfig, this.hass);\n\n    this.requestUpdate();\n  }\n\n  render(): TemplateResult {\n    // Handle validation errors and configuration issues\n    if (this._validationResult && !this._validationResult.isValid) {\n      // Show error display for any validation issues (critical errors or warnings)\n      return html`\n        <error-display\n          .errors=\"${this._validationResult.errors}\"\n          .title=\"${this._validationResult.hasCriticalErrors ? 'Configuration Error' : 'Configuration Issues'}\"\n        ></error-display>\n      `;\n    }\n\n    // Render normal card only if validation passed completely\n    return this._renderCard();\n  }\n\n  private _renderCard(): TemplateResult {\n\n    const {\n      title ,\n      subtitle,\n      text_color,\n      background_color,\n      progress_color,\n      stroke_width ,\n      icon_size ,\n      expired_animation = true,\n      expired_text = 'Completed!',\n      width,\n      height,\n      aspect_ratio\n    } = this._resolvedConfig;\n\n    // FIXED: Ensure background color has a sensible default\n    const cardBackground = background_color || 'var(--card-background, var(--primary-background-color, #1a1a1a))';\n    const textColor = text_color || 'var(--primary-text-color, #fff)';\n    const mainProgressColor = progress_color || text_color || 'var(--progress-color, #4caf50)';\n\n    // Calculate dynamic circle size based on card dimensions to prevent overflow\n    const dynamicCircleSize = this.styleManager.calculateDynamicIconSize(width, height, aspect_ratio, icon_size);\n    const dynamicStroke = this.styleManager.calculateDynamicStrokeWidth(dynamicCircleSize, stroke_width);\n\n    // Calculate proportional text sizes\n    const proportionalSizes = this.styleManager.calculateProportionalSizes(width, height, aspect_ratio);\n\n    // Generate dimension styles for the card\n    const dimensionStyles = this.styleManager.generateCardDimensionStyles(width, height, aspect_ratio);\n    \n    // FIXED: Compose CSS styles with proper background handling\n    const cardStyles = [\n      `background: ${cardBackground}`, \n      `color: ${textColor}`,\n      `--timeflow-card-background-color: ${cardBackground}`,\n      `--timeflow-card-text-color: ${textColor}`,\n      `--timeflow-card-progress-color: ${mainProgressColor}`,\n      `--timeflow-card-icon-size: ${dynamicCircleSize}px`,\n      `--timeflow-card-stroke-width: ${dynamicStroke}`,\n      `--timeflow-title-size: ${proportionalSizes.titleSize}rem`,\n      `--timeflow-subtitle-size: ${proportionalSizes.subtitleSize}rem`,\n      `--progress-text-color: ${textColor}`,\n      ...dimensionStyles\n    ].join('; ');\n\n    // Compose subtitle text\n    let subtitleText: string;\n    if (this._resolvedConfig.timer_entity && this.hass) {\n      const timerData = TimerEntityService.getTimerData(this._resolvedConfig.timer_entity, this.hass);\n      if (timerData) {\n        // If expired and it's an Alexa or Google timer, show dynamic \"timer complete\" text (with label when available)\n        if (this._expired && (timerData.isAlexaTimer || timerData.isGoogleTimer)) {\n          subtitleText = TimerEntityService.getTimerSubtitle(timerData, this._resolvedConfig.show_seconds !== false);\n        } else if (!this._expired) {\n          subtitleText = subtitle || TimerEntityService.getTimerSubtitle(timerData, this._resolvedConfig.show_seconds !== false);\n        } else {\n          subtitleText = expired_text;\n        }\n      } else {\n        subtitleText = this._expired ? expired_text : (subtitle || this.countdownService.getSubtitle(this._resolvedConfig, this.hass));\n      }\n    } else {\n      // In auto-discovery, always defer to service subtitle (handles Alexa finished/none states)\n      if (this._resolvedConfig.auto_discover_alexa) {\n        subtitleText = subtitle || this.countdownService.getSubtitle(this._resolvedConfig, this.hass);\n      } else {\n        subtitleText = this._expired ? expired_text : (subtitle || this.countdownService.getSubtitle(this._resolvedConfig, this.hass));\n      }\n    }\n\n    // Compose title text with fallback\n    let titleText = title;\n    if (titleText === undefined || titleText === null || (typeof titleText === 'string' && titleText.trim() === '')) {\n      if (this._resolvedConfig.timer_entity && this.hass) {\n        titleText = TimerEntityService.getTimerTitle(\n          this._resolvedConfig.timer_entity,\n          this.hass\n        );\n      } else {\n        // For auto-discovery, avoid stale expired_text as title\n        titleText = (this._resolvedConfig.auto_discover_alexa || this._resolvedConfig.auto_discover_google) ? 'Countdown Timer' : (this._expired ? expired_text : 'Countdown Timer');\n      }\n    }\n\n    // FIXED: Determine card classes including initialization state\n    const cardClasses = [\n      this._initialized ? 'initialized' : '',\n      (this._expired && expired_animation) ? 'expired' : ''\n    ].filter(Boolean).join(' ');\n\n    // Create resolved config \n    const configWithDefaults = { ...this._resolvedConfig };\n    \n    // Map timer_entity to entity field for action handling compatibility\n    if (configWithDefaults.timer_entity && !configWithDefaults.entity) {\n      configWithDefaults.entity = configWithDefaults.timer_entity;\n    }\n    \n    // Following timer-bar-card pattern: Set default tap action if entity exists but no tap action defined\n    if (configWithDefaults.entity && !configWithDefaults.tap_action) {\n      configWithDefaults.tap_action = { action: 'more-info' };\n    }\n\n    // Check if tap action should show pointer cursor (following timer-bar-card logic)\n    const shouldShowPointer = configWithDefaults.tap_action?.action !== \"none\";\n    \n    // Enable action handlers when we have actions (following timer-bar-card pattern)\n    const shouldEnableActions = configWithDefaults.tap_action || configWithDefaults.hold_action || configWithDefaults.double_tap_action;\n\n    return html`\n      <ha-card \n        class=\"${cardClasses}\" \n        style=\"${cardStyles}\"\n        ?actionHandler=${shouldEnableActions}\n        .actionHandler=${shouldEnableActions ? createActionHandler(configWithDefaults) : undefined}\n        @action=${shouldEnableActions && this.hass ? createHandleAction(this.hass, configWithDefaults) : undefined}\n      >\n        <div class=\"card-content\">\n          <header class=\"header\">\n            <div class=\"title-section\">\n              <h2 class=\"title\" aria-live=\"polite\">${titleText}</h2>\n              <p class=\"subtitle\" aria-live=\"polite\">${subtitleText}</p>\n            </div>\n          </header>\n          \n          <div class=\"content\" role=\"group\" aria-label=\"Countdown Progress\">\n            <div class=\"progress-section\">\n              <progress-circle\n                class=\"progress-circle\"\n                .progress=\"${this._progress}\"\n                .color=\"${mainProgressColor}\"\n                .size=\"${dynamicCircleSize}\"\n                .strokeWidth=\"${dynamicStroke}\"\n                aria-label=\"Countdown progress: ${Math.round(this._progress)}%\"\n              ></progress-circle>\n            </div>\n          </div>\n        </div>\n      </ha-card>\n    `;\n  }\n\n  /**\n   * Helper: Returns card size (in Home Assistant's grid rows approx)\n   */\n  getCardSize(): number {\n    const { aspect_ratio = '2/1', height } = this.config;\n    if (height) {\n      const heightValue = parseInt(typeof height === 'string' ? height : height.toString());\n      if (heightValue <= 100) return 1;\n      if (heightValue <= 150) return 2;\n      if (heightValue <= 200) return 3;\n      return 4;\n    }\n    if (aspect_ratio) {\n      const [width, height] = aspect_ratio.split('/').map(Number);\n      if (!width || !height) return 3;\n      const ratio = height / width;\n      if (ratio >= 1.5) return 4;\n      if (ratio >= 1) return 3;\n      if (ratio >= 0.75) return 2;\n      return 2;\n    }\n    return 3;\n  }\n\n  // Static version info\n  static get version() {\n    return '1.3';\n  }\n}","// ProgressCircle.ts\nimport { LitElement, html, css, CSSResult, TemplateResult, PropertyValues } from 'lit';\nimport { property } from 'lit/decorators.js';\n\nexport class ProgressCircle extends LitElement {\n  @property({ type: Number }) progress: number = 0;\n  @property({ type: String }) color: string = '#4CAF50';\n  @property({ type: Number }) size: number = 100;\n  @property({ type: Number }) strokeWidth: number = 15;\n\n  static get styles(): CSSResult {\n    return css`\n      :host {\n        display: inline-block;\n        vertical-align: middle;\n      }\n      .progress-wrapper {\n        position: relative;\n      }\n      svg {\n        display: block;\n        margin: 0 auto;\n      }\n      .updating {\n        transition: stroke-dashoffset 0.3s ease;\n      }\n    `;\n  }\n\n  constructor() {\n    super();\n    this.progress = 0;\n    this.color = '#4CAF50';\n    this.size = 100;\n    this.strokeWidth = 15;\n  }\n\n  updated(changed: PropertyValues): void {\n    // Animate stroke-dashoffset if progress changes\n    if (changed.has('progress')) {\n      const circle = this.renderRoot?.querySelector('.progress-bar') as HTMLElement;\n      if (circle) {\n        circle.classList.add('updating');\n        setTimeout(() => {\n          if (circle) circle.classList.remove('updating');\n        }, 400);\n      }\n    }\n  }\n\n  // Expose imperative API for external modules, as before\n  updateProgress(progress: number, animate: boolean = true): void {\n    if (animate) {\n      this.progress = progress;\n    } else {\n      // Instantly set progress, skips animation\n      const bar = this.renderRoot?.querySelector('.progress-bar') as HTMLElement;\n      this.progress = progress;\n      if (bar) bar.style.transition = 'none';\n      setTimeout(() => { if (bar) bar.style.transition = ''; }, 20);\n    }\n  }\n\n  getProgress(): number {\n    return this.progress;\n  }\n\n  render(): TemplateResult {\n    const safeProgress = Math.max(0, Math.min(100, Number(this.progress) || 0));\n    const size = Number(this.size) || 100;\n    const stroke = Number(this.strokeWidth) || 15;\n    const radius = (size - stroke) / 2;\n    const circumference = 2 * Math.PI * radius;\n    const offset = circumference - (safeProgress / 100) * circumference;\n\n    return html`\n      <div class=\"progress-wrapper\" style=\"width:${size}px; height:${size}px;\">\n        <svg\n          class=\"progress-circle\"\n          height=\"${size}\" width=\"${size}\"\n          style=\"overflow:visible;\"\n        >\n          <circle\n            class=\"progress-bg\"\n            cx=\"${size / 2}\" cy=\"${size / 2}\"\n            r=\"${radius}\"\n            fill=\"none\"\n            stroke=\"#FFFFFF1A\"\n            stroke-width=\"${stroke}\"\n          ></circle>\n          <circle\n            class=\"progress-bar\"\n            cx=\"${size / 2}\" cy=\"${size / 2}\"\n            r=\"${radius}\"\n            fill=\"none\"\n            stroke=\"${this.color}\"\n            stroke-width=\"${stroke}\"\n            stroke-linecap=\"round\"\n            style=\"\n              stroke-dasharray: ${circumference};\n              stroke-dashoffset: ${offset};\n              transition: stroke-dashoffset 0.3s ease;\n              transform: rotate(-90deg);\n              transform-origin: ${size / 2}px ${size / 2}px;\n            \"\n          ></circle>\n        </svg>\n      </div>\n    `;\n  }\n}","import { LitElement, html, css, TemplateResult, CSSResult, nothing } from 'lit';\nimport { property, state } from 'lit/decorators.js';\nimport { CardConfig } from '../types/index';\n\n/**\n * TimeFlow Card Editor\n * Full-featured graphical editor for the TimeFlow custom card.\n * Follows Bubble Card UX patterns: important fields visible, secondary in expandables.\n * Emits `config-changed` events with the updated config.\n */\nexport class TimeFlowCardEditor extends LitElement {\n    @property({ type: Object }) hass: any = null;\n    @state() private _config: CardConfig = { type: 'custom:timeflow-card' } as CardConfig;\n    \n    // Track which date fields are in \"template mode\"\n    @state() private _targetDateTemplateMode: boolean = false;\n    @state() private _creationDateTemplateMode: boolean = false;\n\n    static get styles(): CSSResult {\n        return css`\n            .section-header {\n                font-weight: 500;\n                font-size: 14px;\n                color: var(--primary-text-color);\n                margin: 16px 0 8px 0;\n                padding-bottom: 4px;\n                border-bottom: 1px solid var(--divider-color);\n            }\n            .section-header:first-of-type {\n                margin-top: 8px;\n            }\n            ha-form {\n                display: block;\n            }\n            \n            /* Date field with mode toggle */\n            .date-field-container {\n                display: flex;\n                flex-direction: column;\n                gap: 4px;\n                margin-bottom: 16px;\n            }\n            .date-field-header {\n                display: flex;\n                justify-content: space-between;\n                align-items: center;\n            }\n            .date-field-label {\n                font-weight: 500;\n                font-size: 14px;\n                color: var(--primary-text-color);\n            }\n            .mode-toggle {\n                display: flex;\n                align-items: center;\n                gap: 6px;\n                font-size: 12px;\n                color: var(--secondary-text-color);\n                cursor: pointer;\n                padding: 4px 8px;\n                border-radius: 4px;\n                background: var(--secondary-background-color);\n                border: none;\n            }\n            .mode-toggle:hover {\n                background: var(--primary-color);\n                color: var(--text-primary-color);\n            }\n            .mode-toggle ha-icon {\n                --mdc-icon-size: 16px;\n            }\n            .date-helper {\n                font-size: 12px;\n                color: var(--secondary-text-color);\n                margin-top: 4px;\n            }\n            ha-textfield, input[type=\"datetime-local\"] {\n                width: 100%;\n            }\n            input[type=\"datetime-local\"] {\n                padding: 12px;\n                border: 1px solid var(--divider-color);\n                border-radius: 4px;\n                background: var(--card-background-color);\n                color: var(--primary-text-color);\n                font-size: 14px;\n            }\n            input[type=\"datetime-local\"]:focus {\n                outline: none;\n                border-color: var(--primary-color);\n            }\n            .date-fields-section {\n                display: flex;\n                flex-direction: column;\n                gap: 16px;\n                padding: 16px 0;\n            }\n        `;\n    }\n\n    setConfig(config: CardConfig) {\n        this._config = { ...config } as CardConfig;\n        \n        // Auto-detect if existing values are templates\n        const targetDate = config.target_date || '';\n        const creationDate = config.creation_date || '';\n        this._targetDateTemplateMode = this._isTemplate(targetDate);\n        this._creationDateTemplateMode = this._isTemplate(creationDate);\n    }\n    \n    private _isTemplate(value: string): boolean {\n        return value.includes('{{') || value.includes('{%');\n    }\n    \n    private _convertToDatetimeLocal(isoDate: string): string {\n        if (!isoDate || this._isTemplate(isoDate)) return '';\n        // Convert ISO format to datetime-local format (YYYY-MM-DDTHH:MM)\n        try {\n            const date = new Date(isoDate);\n            if (isNaN(date.getTime())) return '';\n            return date.toISOString().slice(0, 16);\n        } catch {\n            return '';\n        }\n    }\n    \n    private _convertFromDatetimeLocal(localDate: string): string {\n        if (!localDate) return '';\n        // Convert datetime-local to ISO format with seconds\n        return localDate + ':00';\n    }\n\n    private _fireConfigChanged(config: CardConfig) {\n        this.dispatchEvent(new CustomEvent('config-changed', {\n            detail: { config },\n            bubbles: true,\n            composed: true\n        }));\n    }\n\n    private _formChanged(ev: CustomEvent) {\n        const value = ev.detail?.value || {};\n        // Merge with existing config and keep the card type\n        const newConfig = { ...(this._config || {}), ...value, type: this._config?.type || 'custom:timeflow-card' } as CardConfig;\n        this._config = newConfig;\n        this._fireConfigChanged(newConfig);\n    }\n\n    private _computeHelper(schema: any): string {\n        const helpers: Record<string, string> = {\n            // Timer Source\n            'timer_entity': 'Select a timer, sensor, or input_datetime entity',\n            'target_date': 'ISO date, entity, or template: \"2024-12-31T23:59:59\", \"{{ states(\\'input_datetime.deadline\\') }}\"',\n            'creation_date': 'Start date for progress calculation (optional)',\n            'auto_discover_alexa': 'Automatically find active Alexa timers',\n            'auto_discover_google': 'Automatically find active Google Home timers',\n            'alexa_device_filter': 'Comma-separated list of Alexa device names or IDs to filter timers (e.g., \"Kitchen, Living Room\")',\n            'prefer_labeled_timers': 'Prefer timers with labels over unnamed ones',\n            \n            // Display\n            'title': 'Card title - supports templates: \"{{ states(\\'sensor.event_name\\') }}\"',\n            'subtitle': 'Shows time remaining by default; only set for custom text',\n            'expired_text': 'Text shown when countdown completes',\n            'compact_format': '\"2d 5h 30m\" vs \"2 days 5 hours 30 minutes\"',\n            \n            // Colors\n            'progress_color': 'Progress circle color (hex, name, rgb, or template)',\n            'background_color': 'Card background color',\n            'text_color': 'Text color for title and countdown',\n            \n            // Layout\n            'width': 'Card width (e.g., \"300px\", \"100%\", \"20em\")',\n            'height': 'Card height (e.g., \"200px\", \"auto\")',\n            'aspect_ratio': 'Width:height ratio (e.g., \"16/9\", \"4/3\", \"1/1\")',\n            \n            // Progress Circle\n            'stroke_width': 'Thickness of the progress circle ring',\n            'icon_size': 'Size of the progress circle',\n        };\n        return helpers[schema.name] || '';\n    }\n\n    private _computeLabel(schema: any): string {\n        if (schema.label)\n            return schema.label;\n\n        const labels: Record<string, string> = {\n            'timer_entity': 'Timer Entity',\n            'target_date': 'Target Date/Time',\n            'creation_date': 'Start Date (for progress)',\n            'auto_discover_alexa': 'Auto-discover Alexa Timers',\n            'auto_discover_google': 'Auto-discover Google Timers',\n            'alexa_device_filter': 'Alexa Device Filter',\n            'prefer_labeled_timers': 'Prefer Labeled Timers',\n            'show_alexa_device': 'Show Alexa Device Name',\n            'show_days': 'Days',\n            'show_hours': 'Hours',\n            'show_minutes': 'Minutes',\n            'show_seconds': 'Seconds',\n            'show_months': 'Months',\n            'compact_format': 'Compact Format',\n            'expired_animation': 'Expired Animation',\n            'expired_text': 'Expired Text',\n            'progress_color': 'Progress Color',\n            'background_color': 'Background Color',\n            'text_color': 'Text Color',\n            'stroke_width': 'Stroke Width',\n            'icon_size': 'Circle Size',\n            'aspect_ratio': 'Aspect Ratio',\n        };\n\n        if (labels[schema.name]) return labels[schema.name];\n\n        const key = (schema.name ?? '').toString();\n        if (!key) return '';\n        return key\n            .split('_')\n            .map((part: string) => part.charAt(0).toUpperCase() + part.slice(1))\n            .join(' ');\n    }\n    \n    private _renderDateField(\n        configKey: 'target_date' | 'creation_date',\n        label: string,\n        helper: string,\n        templateMode: boolean,\n        toggleCallback: () => void\n    ): TemplateResult {\n        const value = this._config[configKey] || '';\n        \n        return html`\n            <div class=\"date-field-container\">\n                <div class=\"date-field-header\">\n                    <span class=\"date-field-label\">${label}</span>\n                    <button \n                        class=\"mode-toggle\" \n                        @click=${toggleCallback}\n                        title=${templateMode ? 'Switch to date picker' : 'Switch to template/Jinja mode'}\n                    >\n                        <ha-icon icon=${templateMode ? 'mdi:calendar' : 'mdi:code-braces'}></ha-icon>\n                        ${templateMode ? 'Picker' : 'Template'}\n                    </button>\n                </div>\n                \n                ${templateMode \n                    ? html`\n                        <ha-textfield\n                            .value=${value}\n                            .placeholder=${'{{ states(\\'input_datetime.my_date\\') }}'}\n                            @input=${(e: Event) => this._updateDateField(configKey, (e.target as HTMLInputElement).value)}\n                        ></ha-textfield>\n                        <div class=\"date-helper\">Enter Jinja template, entity, or ISO date string</div>\n                    `\n                    : html`\n                        <input \n                            type=\"datetime-local\"\n                            .value=${this._convertToDatetimeLocal(value)}\n                            @input=${(e: Event) => this._updateDateField(configKey, this._convertFromDatetimeLocal((e.target as HTMLInputElement).value))}\n                        />\n                        <div class=\"date-helper\">${helper}</div>\n                    `\n                }\n            </div>\n        `;\n    }\n    \n    private _updateDateField(configKey: string, value: string): void {\n        const newConfig = { ...this._config, [configKey]: value };\n        this._config = newConfig as CardConfig;\n        this._fireConfigChanged(newConfig as CardConfig);\n    }\n    \n    private _toggleTargetDateMode(): void {\n        this._targetDateTemplateMode = !this._targetDateTemplateMode;\n    }\n    \n    private _toggleCreationDateMode(): void {\n        this._creationDateTemplateMode = !this._creationDateTemplateMode;\n    }\n\n    /**\n     * Compute the effective compact_format state for display\n     * Auto-enables when 3+ units are selected (unless explicitly disabled)\n     */\n    private _getEffectiveCompactFormat(): boolean {\n        const { show_months, show_days, show_hours, show_minutes, show_seconds, compact_format } = this._config;\n        \n        // If explicitly set, use that value\n        if (compact_format !== undefined) {\n            return compact_format;\n        }\n        \n        // Otherwise, auto-enable if 3+ units are shown\n        const enabledUnits = [show_months, show_days, show_hours, show_minutes, show_seconds].filter(v => v === true).length;\n        return enabledUnits >= 3;\n    }\n\n    render(): TemplateResult {\n        const cfg = this._config || {};\n        \n        // Create a display config that shows the effective compact_format state\n        const displayCfg = {\n            ...cfg,\n            // Show the effective compact_format value for UI consistency\n            compact_format: this._getEffectiveCompactFormat()\n        };\n\n        const schema = [\n            // \n            // TIMER SOURCE - Most important, always visible at top\n            // \n            { name: 'timer_entity', selector: { entity: { domain: ['timer', 'sensor', 'input_datetime'] } } },\n            \n            // Smart Assistant Auto-Discovery (visible toggles)\n            {\n                type: 'grid',\n                schema: [\n                    { name: 'auto_discover_alexa', selector: { boolean: {} } },\n                    { name: 'auto_discover_google', selector: { boolean: {} } },\n                ]\n            },\n            \n            // \n            // DISPLAY - Title, subtitle, and expired text\n            // \n            { name: 'title', selector: { text: {} } },\n            { name: 'subtitle', selector: { text: {} } },\n            { name: 'expired_text', selector: { text: {} } },\n            \n            // \n            // TIME UNITS - Always visible as grid\n            // \n            {\n                type: 'grid',\n                schema: [\n                    { name: 'show_months', selector: { boolean: {} } },\n                    { name: 'show_days', selector: { boolean: {} } },\n                    { name: 'show_hours', selector: { boolean: {} } },\n                    { name: 'show_minutes', selector: { boolean: {} } },\n                    { name: 'show_seconds', selector: { boolean: {} } },\n                    { name: 'compact_format', selector: { boolean: {} } },\n                ]\n            },\n            \n            // \n            // APPEARANCE - Expandable (secondary settings)\n            // \n            {\n                type: \"expandable\",\n                title: \"Appearance\",\n                icon: \"mdi:palette\",\n                schema: [\n                    { name: 'progress_color', selector: { text: {} } },\n                    { name: 'background_color', selector: { text: {} } },\n                    { name: 'text_color', selector: { text: {} } },\n                    { name: 'expired_animation', selector: { boolean: {} } },\n                ]\n            },\n            \n            // \n            // LAYOUT - Expandable\n            // \n            {\n                type: \"expandable\",\n                title: \"Layout\",\n                icon: \"mdi:page-layout-body\",\n                schema: [\n                    {\n                        type: 'grid',\n                        schema: [\n                            { name: 'width', selector: { text: {} } },\n                            { name: 'height', selector: { text: {} } },\n                        ]\n                    },\n                    { name: 'aspect_ratio', selector: { text: {} } },\n                ]\n            },\n            \n            // \n            // PROGRESS CIRCLE - Expandable\n            // \n            {\n                type: \"expandable\",\n                title: \"Progress Circle\",\n                icon: \"mdi:circle-slice-3\",\n                schema: [\n                    {\n                        type: \"grid\",\n                        schema: [\n                            { name: 'stroke_width', selector: { number: { min: 1, max: 50, step: 1 } } },\n                            { name: 'icon_size', selector: { number: { min: 10, max: 350, step: 5 } } },\n                        ]\n                    },\n                ]\n            },\n            \n            // \n            // ALEXA/GOOGLE OPTIONS - Expandable\n            // \n            {\n                type: \"expandable\",\n                title: \"Smart Assistant Options\",\n                icon: \"mdi:home-assistant\",\n                schema: [\n                    { name: 'alexa_device_filter', selector: { text: {} } },\n                    { name: 'prefer_labeled_timers', selector: { boolean: {} } },\n                    { name: 'show_alexa_device', selector: { boolean: {} } },\n                ]\n            },\n            \n            // \n            // ACTIONS - Expandable\n            // \n            {\n                type: \"expandable\",\n                title: \"Tap Actions\",\n                icon: \"mdi:gesture-tap\",\n                schema: [\n                    { name: 'tap_action', selector: { ui_action: {} } },\n                    { name: 'hold_action', selector: { ui_action: {} } },\n                    { name: 'double_tap_action', selector: { ui_action: {} } },\n                ]\n            },\n        ];\n\n        return html`\n            <!-- Date Fields with Template Toggle -->\n            <div class=\"date-fields-section\">\n                ${this._renderDateField(\n                    'target_date',\n                    'Target Date',\n                    'Date/time when countdown ends',\n                    this._targetDateTemplateMode,\n                    () => this._toggleTargetDateMode()\n                )}\n                \n                ${this._renderDateField(\n                    'creation_date',\n                    'Creation Date',\n                    'Start date (defaults to now)',\n                    this._creationDateTemplateMode,\n                    () => this._toggleCreationDateMode()\n                )}\n            </div>\n            \n            <ha-form\n                .hass=${this.hass}\n                .data=${displayCfg}\n                .schema=${schema}\n                @value-changed=${(e: CustomEvent) => this._formChanged(e)}\n                .computeLabel=${this._computeLabel}\n                .computeHelper=${this._computeHelper}\n            ></ha-form>\n        `;\n    }\n\n}\n\nexport default TimeFlowCardEditor;\n","/**\n * TimeFlow Card - Entry point for modular architecture with Lit components\n * Registers Lit-based custom elements and exposes the card to Home Assistant\n */\n\n// Type declarations for Home Assistant globals\ndeclare global {\n  interface Window {\n    customCards?: Array<{\n      type: string;\n      name: string;\n      description: string;\n      preview?: boolean;\n      documentationURL?: string;\n    }>;\n  }\n}\n\nimport { TimeFlowCard } from './components/TimeFlowCard';\nimport { ProgressCircle } from './components/ProgressCircle';\nimport { ErrorDisplay } from './utils/ErrorDisplay';\nimport { TimeFlowCardEditor } from './components/TimeFlowCardEditor';\n\n// Register Lit custom elements with duplicate protection\nif (!customElements.get('error-display')) {\n  customElements.define('error-display', ErrorDisplay);\n} else {\n  // Component already registered\n}\n\nif (!customElements.get('progress-circle')) {\n  customElements.define('progress-circle', ProgressCircle);\n} else {\n  // Component already registered\n}\n\nif (!customElements.get('timeflow-card')) {\n  customElements.define('timeflow-card', TimeFlowCard);\n} else {\n  // Component already registered\n}\n\nif (!customElements.get('timeflow-card-editor')) {\n  customElements.define('timeflow-card-editor', TimeFlowCardEditor);\n} else {\n  // Component already registered\n}\n\n// Editor registration hint for Lovelace (the editor element itself is registered in its file)\nwindow.customCards = window.customCards || [];\n\n// Register the card with Home Assistant\nwindow.customCards = window.customCards || [];\nwindow.customCards.push({\n  type: 'timeflow-card',\n  name: 'TimeFlow Card',\n  description: 'A beautiful countdown timer card with progress circle for Home Assistant, using Lit',\n  preview: true,\n  documentationURL: 'https://github.com/Rishi8078/TimeFlow-Card' // Update if needed\n});\n\n// Export main classes for external use or testing\nexport { TimeFlowCard, ProgressCircle, ErrorDisplay };"],"names":["__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","SuppressedError","t","globalThis","e","ShadowRoot","ShadyCSS","nativeShadow","Document","prototype","CSSStyleSheet","s","Symbol","o","WeakMap","n$3","constructor","this","_$cssResult$","Error","cssText","styleSheet","get","replaceSync","set","toString","reduce","n","cssRules","is","h","getOwnPropertyNames","getOwnPropertySymbols","getPrototypeOf","a","trustedTypes","l","emptyScript","p","reactiveElementPolyfillSupport","u","toAttribute","Boolean","Array","JSON","stringify","fromAttribute","Number","parse","f","b","attribute","type","String","converter","reflect","useDefault","hasChanged","metadata","litPropertyMetadata","HTMLElement","addInitializer","_$Ei","push","observedAttributes","finalize","_$Eh","keys","createProperty","state","hasOwnProperty","create","wrapped","elementProperties","noAccessor","getPropertyDescriptor","call","requestUpdate","configurable","enumerable","getPropertyOptions","Map","finalized","properties","_$Eu","elementStyles","finalizeStyles","styles","isArray","Set","flat","reverse","unshift","toLowerCase","super","_$Ep","isUpdatePending","hasUpdated","_$Em","_$Ev","_$ES","Promise","enableUpdating","_$AL","_$E_","forEach","addController","_$EO","add","renderRoot","isConnected","hostConnected","removeController","delete","size","createRenderRoot","shadowRoot","attachShadow","shadowRootOptions","adoptedStyleSheets","map","document","createElement","litNonce","setAttribute","textContent","appendChild","connectedCallback","disconnectedCallback","hostDisconnected","attributeChangedCallback","_$AK","_$ET","removeAttribute","_$Ej","hasAttribute","C","_$EP","has","_$Eq","reject","scheduleUpdate","performUpdate","shouldUpdate","willUpdate","hostUpdate","update","_$EM","_$AE","hostUpdated","firstUpdated","updated","updateComplete","getUpdateComplete","y","mode","ReactiveElement","reactiveElementVersions","createPolicy","createHTML","Math","random","toFixed","slice","createComment","v","_","m","RegExp","g","$","x","_$litType$","strings","values","T","for","E","A","createTreeWalker","P","V","lastIndex","exec","test","startsWith","N","parts","el","currentNode","content","firstChild","replaceWith","childNodes","nextNode","nodeType","hasAttributes","getAttributeNames","endsWith","getAttribute","split","index","name","ctor","H","I","L","k","tagName","append","data","indexOf","innerHTML","S","_$Co","_$Cl","_$litDirective$","_$AO","_$AT","_$AS","M","_$AV","_$AN","_$AD","_$AM","parentNode","_$AU","creationScope","importNode","R","nextSibling","z","_$AI","_$Cv","_$AH","_$AA","_$AB","options","startNode","endNode","_$AR","iterator","O","insertBefore","createTextNode","_$AC","_$AP","remove","setConnected","element","fill","j","toggleAttribute","capture","once","passive","removeEventListener","addEventListener","handleEvent","host","litHtmlPolyfillSupport","litHtmlVersions","renderOptions","_$Do","renderBefore","render","_$litPart$","_$litElement$","litElementHydrateSupport","LitElement","litElementPolyfillSupport","litElementVersions","kind","init","StandardTimerService","getStandardTimerData","entityId","entity","parseDuration","attributes","isActive","isPaused","isIdle","duration","remaining","finishesAt","finishes_at","Date","isNaN","getTime","max","floor","now","progress","elapsed","min","isAlexaTimer","AlexaTimerService","getAlexaTimerData","hass","isISOTimestamp","activeTimers","_a","parseJson","sorted_active","allTimers","_b","sorted_all","totalActive","_d","_c","total_active","totalAll","_f","_e","total_all","activeMap","entry","extractTimerEntry","id","allMap","nowTs","cache","alexaIdCache","finishedActiveIds","entries","trig","triggerTime","sort","finishedWhileActiveId","primaryId","isFinished","primaryTimer","_g","_h","bestId","best","shortest","POSITIVE_INFINITY","_j","remainingTime","mostRecentPaused","latest","Infinity","status","lastUpdatedDate","rtMs","odMs","originalDurationInMillis","parseFloat","includes","original_duration","last_changed","start","end","label","extractTimerLabel","firstActive","firstAll","finished","alexaDevice","extractAlexaDevice","timerLabel","timerStatus","userDefinedLabel","parseLegacyAlexaTimer","hasOriginalDuration","startTime","endTime","lastChanged","timeSinceChanged","estimatedDuration","friendly_name","timer_label","formatAlexaTimerName","undefined","discoverAlexaTimers","getTimerData","states","alexaTimers","hasActive","hasPaused","timerData","src","deviceName","replace","trim","devicePart","toUpperCase","device_name","device","GoogleTimerService","getGoogleTimerData","timers","entityCache","googleIdCache","finishedTimerId","lastDuration","lastLabel","isGoogleTimer","googleTimerId","googleTimerStatus","allTimersMap","timer","timer_id","finishedCandidates","timerId","fire_time","fireTime","finishedTimer","some","primaryTimerId","earliestFireTime","statusStr","isRinging","pausedSnapshots","previousSnapshot","fireTimeMs","pausedAt","wasActive","discoverGoogleTimers","googleTimers","clearFinishedTimer","TimerEntityService","isTimerEntity","str","seconds","formatRemainingTime","showSeconds","hours","minutes","padStart","getTimerTitle","customTitle","formatGoogleTimerName","isTimerExpired","getTimerSubtitle","getTimerStateColor","defaultColor","DateParser","parseISODate","dateString","manualResult","parseISODateManual","nativeResult","isValidDateResult","parseISODateFallback","dateObj","originalString","timestamp","minTimestamp","maxTimestamp","year","getFullYear","isLeapYear","datePart","timePart","month","day","isValidDateComponents","hour","minute","second","isValidTimeComponents","parseInt","error","ConfigValidator","validateConfig","config","errors","field","message","severity","suggestion","value","isValid","hasCriticalErrors","hasWarnings","target_date","isValidDateInput","timer_entity","auto_discover_alexa","isValidEntityId","creation_date","isValidColorInput","isValidDimensionInput","aspect_ratio","isValidAspectRatioInput","stroke_width","isValidNumberInput","isValidBooleanInput","isValidTextInput","isValidStylesInput","_addHelpfulValidations","safeConfig","_generateSafeConfig","criticalErrors","filter","warnings","tomorrow","setDate","getDate","toISOString","background_color","progress_color","icon_size","validateConfigLegacy","result","join","isTemplate","date","pxMatch","match","px","percentMatch","percent","validUnits","unit","regex","unitValue","aspectMatch","width","height","parsed","pattern","validStyleKeys","styleKeys","every","TemplateService","templateResults","templateCacheLimit","evaluateTemplate","template","cacheKey","cached","isValidTemplate","callApi","fallback","extractFallbackFromTemplate","enforceTemplateCacheLimit","innerTemplate","simpleOrPattern","simpleOrMatch","chainedOrPattern","chainedMatch","conditionalPattern","conditionalMatch","reverseConditionalPattern","reverseMatch","resolveValue","card","clearTemplateCache","clear","cacheEntries","from","entriesToRemove","hasTemplatesInConfig","prop","escapeHtml","text","CountdownService","templateService","dateParser","timeRemaining","months","days","total","expired","lastAlexaTimerData","updateCountdown","_timerDataToCountdownState","auto_discover_google","smartTimers","chosen","find","targetDateValue","targetDate","difference","show_months","show_days","show_hours","show_minutes","show_seconds","totalMilliseconds","extraDays","extraHours","extraMinutes","extraSeconds","calculateProgress","creationDate","creationDateValue","totalDuration","getMainDisplay","getSubtitle","firstDiscovered","expired_text","compact_format","compact","charAt","getTimeRemaining","isExpired","getAvailableAlexaTimers","getAvailableGoogleTimers","getCurrentTimerEntity","StyleManager","dynamicIconSize","dynamicStrokeWidth","customStyles","lastConfigHash","processStyles","style","buildStylesObject","configHash","processedStyles","title","subtitle","progress_circle","_getCardDimensions","defaultWidth","defaultHeight","cardWidth","cardHeight","parseDimension","ratioW","ratioH","calculateDynamicIconSize","configKey","lastIconConfigHash","proportionalSize","baseSize","MIN_ICON_SIZE","MAX_ICON_SIZE","calculateDynamicStrokeWidth","iconSize","lastStrokeConfigHash","MIN_STROKE","MAX_STROKE","ratio","calculated","round","calculateProportionalSizes","defaultArea","scaleFactor","sqrt","titleSize","subtitleSize","dimension","dimStr","pixels","generateCardDimensionStyles","cardStyles","formattedWidth","_formatDimensionValue","formattedHeight","strValue","numValue","clearCache","getCardDimensions","_$Ct","_$Ci","handleAction","node","_hass","action","detail","event","CustomEvent","bubbles","cancelable","composed","dispatchEvent","fireEvent","actionHandlerBind","actionhandler","body","querySelector","getActionHandler","bind","actionHandler","directive","Directive","part","noChange","_options","hasAction","ErrorDisplay","css","html","relevantErrors","property","customElements","define","TimeFlowCard","getConfigElement","getStubConfig","_resolvedConfig","_progress","_countdown","_expired","_validationResult","_initialized","_timerId","countdownService","styleManager","stubConfig","expired_animation","setConfig","validationResult","_updateCountdownAndRender","then","err","_startCountdownUpdates","_stopCountdownUpdates","changedProperties","setInterval","clearInterval","resolvedConfig","templateKeys","resolvedValue","_renderCard","text_color","cardBackground","textColor","mainProgressColor","dynamicCircleSize","dynamicStroke","proportionalSizes","dimensionStyles","subtitleText","titleText","cardClasses","configWithDefaults","tap_action","shouldEnableActions","hold_action","double_tap_action","hasHold","hasDoubleClick","ev","createHandleAction","getCardSize","heightValue","version","ProgressCircle","color","strokeWidth","changed","circle","classList","setTimeout","updateProgress","animate","bar","transition","getProgress","safeProgress","stroke","radius","circumference","PI","offset","TimeFlowCardEditor","_config","_targetDateTemplateMode","_creationDateTemplateMode","_isTemplate","_convertToDatetimeLocal","isoDate","_convertFromDatetimeLocal","localDate","_fireConfigChanged","_formChanged","newConfig","_computeHelper","schema","alexa_device_filter","prefer_labeled_timers","_computeLabel","labels","show_alexa_device","_renderDateField","helper","templateMode","toggleCallback","_updateDateField","_toggleTargetDateMode","_toggleCreationDateMode","_getEffectiveCompactFormat","enabledUnits","displayCfg","selector","domain","boolean","icon","number","step","ui_action","window","customCards","description","preview","documentationURL"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,16]}